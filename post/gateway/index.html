<!doctype html><html lang=zh-cn><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-CWBXLVG90W"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CWBXLVG90W")}</script><meta charset=UTF-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=robots content="index, follow"><meta name=author content><meta name=description content="成功只有一个:按照自己的方式，去度过人生
"><link rel=author type=text/plain href=/humans.txt><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileImage content="/mstile-144x144.png"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><link rel=mask-icon href=/safari-pinned-tab.svg color=#494f5c><meta itemprop=name content="网关限流的策略"><meta itemprop=description content="最近在做一个基于 Pingora 的 AI 网关，限流是其中一个重要问题。在这里做一下记录
为什么网关需要限流 网关作为系统的入口，承担着连接客户端和后端服务的重要角色。限流机制在网关层面实现有以下几个关键原因："><meta itemprop=datePublished content="2024-04-18T18:12:04+08:00"><meta itemprop=dateModified content="2024-04-18T18:12:04+08:00"><meta itemprop=wordCount content="4804"><meta itemprop=keywords content="网关,系统设计"><meta property="og:url" content="https://chi-kai.github.io/post/gateway/"><meta property="og:site_name" content="悉达多"><meta property="og:title" content="网关限流的策略"><meta property="og:description" content="最近在做一个基于 Pingora 的 AI 网关，限流是其中一个重要问题。在这里做一下记录
为什么网关需要限流 网关作为系统的入口，承担着连接客户端和后端服务的重要角色。限流机制在网关层面实现有以下几个关键原因："><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-04-18T18:12:04+08:00"><meta property="article:modified_time" content="2024-04-18T18:12:04+08:00"><meta property="article:tag" content="网关"><meta property="article:tag" content="系统设计"><meta name=twitter:card content="summary"><meta name=twitter:title content="网关限流的策略"><meta name=twitter:description content="最近在做一个基于 Pingora 的 AI 网关，限流是其中一个重要问题。在这里做一下记录
为什么网关需要限流 网关作为系统的入口，承担着连接客户端和后端服务的重要角色。限流机制在网关层面实现有以下几个关键原因："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"网关限流的策略","name":"网关限流的策略","description":"最近在做一个基于 Pingora 的 AI 网关，限流是其中一个重要问题。在这里做一下记录\n为什么网关需要限流 网关作为系统的入口，承担着连接客户端和后端服务的重要角色。限流机制在网关层面实现有以下几个关键原因：\n","keywords":["网关","系统设计"],"articleBody":"最近在做一个基于 Pingora 的 AI 网关，限流是其中一个重要问题。在这里做一下记录\n为什么网关需要限流 网关作为系统的入口，承担着连接客户端和后端服务的重要角色。限流机制在网关层面实现有以下几个关键原因：\n保护后端服务：防止突发流量导致后端服务过载崩溃，确保系统稳定性 资源合理分配：在有限资源条件下，确保资源被公平合理地分配给各个用户 防止恶意攻击：限制单一来源的请求频率，有效防范 DDoS 等恶意攻击 服务质量保障：通过限制总体流量，保证系统响应时间和服务质量 成本控制：特别是对于 AI 服务，限流直接关系到 API 调用成本控制 常见限流算法 下面先解释几种常见的限流算法。固定窗口计数器，滑动窗口计数器，令牌桶算法，和 漏桶算法。\n固定窗口计数器（Fixed Window Counter） 固定窗口计数器是最简单直观的限流算法：\n将时间划分为固定长度的窗口（如 1 分钟、1 小时） 在每个窗口内维护一个计数器，记录请求数量 当计数器达到预设阈值时，拒绝后续请求 在新窗口开始时，计数器重置为零 给出一个实现的示例代码：\nstruct FixedWindowCounter { window_size_ms: u64, // 窗口大小（毫秒） max_requests: u32, // 窗口内最大请求数 current_count: u32, // 当前计数 window_start: u64, // 当前窗口开始时间 } impl FixedWindowCounter { fn allow_request(\u0026mut self, current_time_ms: u64) -\u003e bool { // 检查是否需要重置窗口 if current_time_ms \u003e= self.window_start + self.window_size_ms { self.current_count = 0; self.window_start = current_time_ms; } // 检查是否允许请求 if self.current_count \u003c self.max_requests { self.current_count += 1; return true; } false } } 优点： 实现简单，计算开销小，内存占用少，适合简单场景和单机部署。\n缺点： 最大的缺点是存在边界突刺问题，即在窗口边界可能出现瞬间流量翻倍的情况。比如用户在 12:00:59 发送 100 个请求，然后在 12:01:01 又发送 100 个请求，实际上 2 秒内发送了 200 个请求，远超期望的速率。\n滑动窗口计数器（Sliding Window） 滑动窗口算法通过更精细的时间划分，解决固定窗口的边界问题：\n将时间窗口细分为多个小格（bucket） 每个格子记录各自时间段内的请求数 窗口随时间推移，动态计算当前有效时间范围内的请求总数 当总数超过阈值时拒绝请求 struct SlidingWindow { window_size_ms: u64, // 窗口大小（毫秒） bucket_size_ms: u64, // 每个桶的大小（毫秒） max_requests: u32, // 窗口内最大请求数 buckets: Vec\u003c(u64, u32)\u003e, // (桶开始时间, 请求数) } impl SlidingWindow { fn allow_request(\u0026mut self, current_time_ms: u64) -\u003e bool { // 移除过期的桶 let expire_time = current_time_ms - self.window_size_ms; self.buckets.retain(|(time, _)| *time \u003e= expire_time); // 计算当前总请求数 let total_requests: u32 = self.buckets.iter().map(|(_, count)| count).sum(); // 检查是否允许请求 if total_requests \u003c self.max_requests { // 找到或创建当前时间对应的桶 let current_bucket_time = current_time_ms / self.bucket_size_ms * self.bucket_size_ms; if let Some(idx) = self.buckets.iter().position(|(time, _)| *time == current_bucket_time) { self.buckets[idx].1 += 1; } else { self.buckets.push((current_bucket_time, 1)); } return true; } false } } 优点：: 避免边界突刺问题，能够较好地处理突发流量。\n缺点：: 实现复杂度高于固定窗口，内存占用较大，特别是在分布式环境中同步复杂度增加。\n令牌桶算法（Token Bucket） 令牌桶算法是一种更灵活的限流方式：\n系统维护一个固定容量的令牌桶 以固定速率向桶中添加令牌（如每秒 10 个） 每个请求消耗一个或多个令牌 如果桶中令牌不足，请求被拒绝或等待 令牌桶可以存储一定数量的令牌，允许突发流量 struct TokenBucket { capacity: u32, // 桶容量 rate_per_ms: f64, // 每毫秒生成的令牌数 tokens: f64, // 当前令牌数 last_refill_time: u64, // 上次填充令牌的时间 } impl TokenBucket { fn allow_request(\u0026mut self, current_time_ms: u64, tokens_required: u32) -\u003e bool { // 计算从上次填充到现在应该添加的令牌数 let time_passed = current_time_ms - self.last_refill_time; let new_tokens = time_passed as f64 * self.rate_per_ms; // 更新当前令牌数，不超过容量 self.tokens = (self.tokens + new_tokens).min(self.capacity as f64); self.last_refill_time = current_time_ms; // 检查令牌是否足够 if self.tokens \u003e= tokens_required as f64 { self.tokens -= tokens_required as f64; return true; } false } } 优点：: 能够较好地处理突发流量，提供缓冲能力。基于资源消耗的差异化限流。\n缺点：: 实现复杂，时间精度要求高，影响限流精确性。分布式实现需要额外机制保证一致性。\n漏桶算法（Leaky Bucket） 漏桶算法提供了一种更为严格的速率控制方式：\n将请求比作水滴，放入上方开口的漏桶中 漏桶以固定速率出水（处理请求） 当桶满时，新请求被丢弃 无论输入速率如何变化，输出速率始终恒定 struct LeakyBucket { capacity: u32, // 桶容量 leak_rate_per_ms: f64, // 每毫秒处理的请求数 water_level: u32, // 当前水位（请求数） last_leak_time: u64, // 上次漏水时间 } impl LeakyBucket { fn allow_request(\u0026mut self, current_time_ms: u64) -\u003e bool { // 计算从上次漏水到现在应该处理的请求数 let time_passed = current_time_ms - self.last_leak_time; let leaked = (time_passed as f64 * self.leak_rate_per_ms) as u32; // 更新当前水位，不低于0 self.water_level = self.water_level.saturating_sub(leaked); self.last_leak_time = current_time_ms; // 检查桶是否有空间 if self.water_level \u003c self.capacity { self.water_level += 1; return true; } false } } 优点： 适合需要稳定出口速率的场景。\n缺点： 不允许突发流量，可能导致资源浪费。请求可能需要等待较长时间。\n算法选择和组合 在实际应用中，我们往往需要根据具体场景选择合适的限流算法，甚至将多种算法组合使用：\n固定窗口：适用于简单场景和统计类需求 滑动窗口：适用于需要平滑控制且资源充足的场景 令牌桶：适用于允许突发流量但需要控制长期平均速率的场景 漏桶：适用于需要严格控制出口速率的场景 在 Charon AI 网关中，我们主要采用令牌桶和滑动窗口的组合策略，针对不同维度（用户、IP、服务）采用不同的算法，以实现最佳的限流效果。\nAI 网关相比传统网关的特殊性 AI 网关与传统 API 网关相比，具有一些独特的特性和挑战：\n资源消耗差异大：AI 请求的资源消耗差异极大，例如大模型推理与小模型推理的计算资源需求可能相差 10 倍以上 请求参数影响资源：输入 token 数量、上下文长度等参数直接影响资源消耗，需要参数级别的限流 响应时间不确定：AI 模型的响应时间波动较大，需要更复杂的超时和重试策略 多维度计费模型：AI 服务通常基于多种指标计费（如 token 数、请求数），限流需要考虑多维度 服务质量敏感：用户对 AI 服务的响应时间和稳定性要求较高，需要更精细的限流策略 AI 网关的限流策略 基于上面的分析，AI 网关的限流策略可以分为两个主要方向：\n用户侧限流：控制来自客户端的请求频率和总量，在 AI 网关的特殊性下，需要更复杂的限流策略，针对用户、IP、服务等多个维度进行限流。 服务侧限流：管理发往后端 AI 服务提供商的请求频率，不同服务提供商的资源消耗和响应时间不同，需要不同的限流策略。比如 chatgpt 和 deepseek 的价格，响应时间，资源消耗都不同。 这种双向限流机制既避免 Token 被滥用，也确保了用户资源的合理分配。\n用户侧限流 当一个请求进入 AI 网关时，会经历以下限流检查流程：\n请求预处理：解析请求头，提取 API 密钥、IP 地址、请求路径等信息 多维度限流检查： API 密钥限流：检查该密钥的请求频率和总量是否超限 IP 限流：检查源 IP 地址的请求频率是否超限,防止单一 IP 发送过多请求 请求特征限流：基于请求参数（如模型类型、上下文长度）进行限流判断,对某些高消耗的端点（如长上下文模型请求）设置更严格的限制 限流决策： 如果任一维度超限，返回 429 状态码，并附带 Retry-After 头 如果接近限制但未超限，可能进入排队机制 如果未超限，请求继续处理 计数更新：请求通过限流检查后，更新相应维度的计数器 请求处理：将请求转发到后端 AI 服务 整个流程的核心是确保在请求实际处理前就完成限流决策，避免资源浪费。\n分布式计数器系统 用户侧限流的核心是分布式计数器系统，它负责在分布式环境中准确追踪各维度的请求数量。\n架构设计 我们采用二级架构实现分布式计数器：\nRedis 作为共享计数存储\n使用 Redis 的原子操作特性确保计数准确性 键设计采用 {user_id}:{resource_type}:{time_window}:{timestamp} 格式, 比如 user1:token:60:1708222400 实现自动过期机制，避免存储膨胀 本地内存缓存层\n每个网关实例维护本地计数缓存，减少网络请求 定期与 Redis 同步，确保数据一致性 使用 LRU 策略管理缓存大小 滑动窗口实现 示例场景: 限制用户每分钟最多 100 次请求。传统固定窗口可能在窗口边界出现\"突刺\"，比如用户在 12:00:59 发送 100 个请求，然后在 12:01:01 又发送 100 个请求，实际上 2 秒内发送了 200 个请求，远超期望的速率。\n我们的滑动窗口算法这样工作：\n把每分钟分成更小的时间桶，比如 6 个 10 秒的桶 每个请求进来时，更新当前时间桶的计数 计算窗口限制时，汇总当前时间往前推一个完整窗口内的所有桶的计数 具体代码逻辑类似这样：\npub fn check_and_increment( \u0026self, user_id: \u0026str, window_size_secs: u64, limit: u64 ) -\u003e Result\u003cbool, Error\u003e { let now = SystemTime::now() .duration_since(UNIX_EPOCH) .unwrap() .as_secs(); // 计算当前桶的起始时间（以10秒为一个桶） let bucket_size = 10; let current_bucket = (now / bucket_size) * bucket_size; // 计算窗口内所有需要检查的桶 let window_start = now - window_size_secs; let mut all_buckets = Vec::new(); // 收集所有桶（整个窗口时间范围内） let mut bucket = current_bucket; while bucket \u003e= window_start / bucket_size * bucket_size { all_buckets.push(bucket); if bucket \u003e= bucket_size { bucket -= bucket_size; } else { break; } } // 使用Redis pipeline批量获取所有桶的计数 let mut pipe = redis::pipe(); let keys: Vec\u003cString\u003e = all_buckets.iter() .map(|b| format!(\"rate:{}:{}:{}\", user_id, window_size_secs, b)) .collect(); for key in \u0026keys { pipe.get(key); } let counts: Vec\u003cOption\u003cu64\u003e\u003e = pipe .query(\u0026mut self.redis_conn)?; // 计算总请求数 let total_count: u64 = counts.iter() .filter_map(|c| *c) .sum(); // 判断是否超限 if total_count \u003e= limit { return Ok(false); // 已达到限制 } // 未超限，递增当前桶的计数 let current_key = format!(\"rate:{}:{}:{}\", user_id, window_size_secs, current_bucket); // 原子递增并设置过期时间 let _: () = redis::pipe() .atomic() .incr(\u0026current_key, 1) .expire(\u0026current_key, window_size_secs as usize + 60) // 窗口大小+额外余量 .query(\u0026mut self.redis_conn)?; Ok(true) // 未达到限制，允许请求 } API 密钥限流 API 密钥限流是用户侧限流的第一道防线，针对已认证用户进行资源分配和使用控制。\n多级限流策略 我们实现了多级限流策略：\n短期速率限制：控制每秒/每分钟的请求数量（QPS/QPM），使用上面的滑动窗口算法实现 长期配额限制：控制每日/每月的总请求量或 token 消耗量，使用上面的分布式计数器实现 差异化模型限制：不同模型类型设置不同的限制阈值，使用差异化的分布式计数器实现 pub struct ApiKeyRateLimiter { redis_client: Arc\u003cRedisClient\u003e, local_cache: Mutex\u003cLruCache\u003cString, u32\u003e\u003e, user_limits: HashMap\u003cString, UserLimits\u003e, } impl ApiKeyRateLimiter { pub fn check_limit(\u0026self, api_key: \u0026str, model: \u0026str, request_size: usize) -\u003e LimitResult { // 1. 检查短期速率限制（QPS） if !self.check_qps_limit(api_key, model).unwrap_or(false) { return LimitResult::RateLimited(5); // 建议 5 秒后重试 } // 2. 检查长期配额限制（每日总量） if !self.check_daily_quota(api_key, request_size).unwrap_or(false) { return LimitResult::QuotaExceeded; } // 3. 检查模型特定限制 if !self.check_model_specific_limit(api_key, model, request_size).unwrap_or(false) { return LimitResult::ModelLimited(10); // 建议 10 秒后重试 } // 通过所有限制检查 LimitResult::Allowed } } pub fn check_daily_quota(\u0026self, api_key: \u0026str, request_size: usize) -\u003e Result\u003cbool, Error\u003e { // 1. 获取当前日期的时间戳（按天计算） let now = SystemTime::now() .duration_since(UNIX_EPOCH) .unwrap() .as_secs(); let day_timestamp = (now / 86400) * 86400; // 取当天的起始时间戳（86400 = 24小时的秒数） // 2. 构造Redis键，格式为 \"quota:{api_key}:daily:{day_timestamp}\" let quota_key = format!(\"quota:{}:daily:{}\", api_key, day_timestamp); // 3. 获取用户的每日配额限制 let user_id = self.get_user_id_from_api_key(api_key)?; let daily_limit = self.user_limits .get(user_id) .map(|limits| limits.daily_quota) .unwrap_or(DEFAULT_DAILY_QUOTA); // 4. 原子操作：检查当前用量并增加请求大小 let mut conn = self.redis_client.get_connection()?; let current_usage: u64 = conn.get(\u0026quota_key).unwrap_or(0); // 5. 判断是否超出配额 if current_usage + request_size as u64 \u003e daily_limit { return Ok(false); // 配额已用尽 } // 6. 未超出配额，增加用量并设置过期时间 let _: () = redis::pipe() .atomic() .incr(\u0026quota_key, request_size as u64) .expire(\u0026quota_key, 86400 + 3600) // 设置为1天+1小时（额外余量防止边界问题） .query(\u0026mut conn)?; Ok(true) // 未达到限制，允许请求 } IP 地址限流 IP 限流主要用于防止恶意攻击和保护未认证请求路径，是系统安全的重要保障。\n自适应阈值 我们实现了基于历史流量模式的自适应阈值：\n基础限制：所有 IP 都有默认的基础请求限制 信誉系统：根据 IP 的历史行为动态调整限制 异常检测：识别异常流量模式，对可疑 IP 实施更严格限制 代码实现 pub struct IpRateLimiter { redis_client: Arc\u003cRedisClient\u003e, suspicious_ip_bloom: BloomFilter\u003cString\u003e, ip_reputation: HashMap\u003cString, f32\u003e, } impl IpRateLimiter { pub fn check_limit(\u0026self, ip_address: \u0026str, limit: u32) -\u003e Result\u003cbool, Error\u003e { // 预筛选：检查是否为可疑 IP（根据历史数据） if self.suspicious_ip_bloom.might_contain(ip_address) { // 对可疑 IP 使用更严格的限制 let strict_limit = limit / 2; return self.check_rate(ip_address, strict_limit); } // 根据 IP 信誉调整限制 let reputation_factor = self.ip_reputation.get(ip_address).unwrap_or(\u00261.0); let adjusted_limit = (limit as f32 * reputation_factor) as u32; self.check_rate(ip_address, adjusted_limit) } } 请求特征限流 请求特征限流是 AI 网关特有的限流维度，针对请求参数和资源消耗进行精细控制。\n差异化限流策略 我们基于以下特征实施差异化限流：\n模型差异化限流：不同模型设置不同 QPS 限制（如 GPT-4 限制为 5 QPS，GPT-3.5 为 20 QPS） 参数敏感限流：大 context_length 请求（如 16K tokens）设置更严格限制 端点差异化：不同 API 端点（如聊天补全、嵌入）设置不同限制 代码实现 pub struct RequestFeatureLimiter { model_limits: HashMap\u003cString, ModelLimits\u003e, endpoint_limits: HashMap\u003cString, u32\u003e, } impl RequestFeatureLimiter { pub fn check_limit(\u0026self, api_key: \u0026str, model: \u0026str, endpoint: \u0026str, context_length: usize) -\u003e LimitResult { // 1. 检查模型特定限制 let model_limit = self.model_limits.get(model) .unwrap_or(\u0026self.model_limits[\"default\"]); // 2. 检查上下文长度限制 let length_factor = if context_length \u003e 8192 { 0.5 // 大上下文请求限制更严格 } else if context_length \u003e 4096 { 0.75 } else { 1.0 }; // 3. 检查端点限制 let endpoint_limit = self.endpoint_limits.get(endpoint) .unwrap_or(\u0026self.endpoint_limits[\"default\"]); // 综合判断 let effective_limit = (model_limit.qps as f32 * length_factor) as u32; if effective_limit \u003c *endpoint_limit { // 使用更严格的限制 self.check_rate(api_key, model, effective_limit) } else { self.check_rate(api_key, endpoint, *endpoint_limit) } } } 智能排队机制 为了提高用户体验，我们实现了智能排队机制，在短期速率超限但资源允许的情况下，不直接拒绝请求而是进行排队处理。\n排队策略 优先级排队：基于用户等级和请求重要性确定队列优先级 超时控制：设置最大等待时间，避免资源无限占用 动态调整：根据系统负载动态调整队列处理速度 代码实现 pub fn handle_request_burst(\u0026self, user_id: \u0026str, request: Request) -\u003e Response { // 检查用户当前使用量 let usage = self.get_current_usage(user_id); let limit = self.get_user_limit(user_id); if usage \u003e limit { // 完全超限，直接拒绝 return Response::rate_limited(429, \"Rate limit exceeded\"); } else if usage \u003e limit * 0.8 { // 接近限制，尝试排队 let priority = self.get_user_priority(user_id); let wait_time = self.queue_manager.enqueue(request, priority); if wait_time \u003e MAX_WAIT_TIME { // 等待时间过长，拒绝请求 return Response::rate_limited(429, \"Queue too long\"); } // 请求进入队列，等待处理 return Response::queued(202, wait_time); } // 未超限，正常处理 self.process_request(request) } 服务侧限流 服务侧限流是管理发往后端 AI 服务提供商的请求频率，不同服务提供商的资源消耗和响应时间不同，需要不同的限流策略。\n多实例协同 在分布式部署环境中，多个网关实例需要协同工作，确保限流的一致性和准确性。\n协同机制 计数同步：使用 Redis 作为中央存储，确保计数一致性 配置共享：限流配置统一存储，所有实例实时获取最新配置 状态广播：关键状态变更（如紧急限流）通过发布订阅机制广播 通过以上机制，我们实现了高性能、高可靠的用户侧限流系统，既保障了系统的稳定性，又提供了良好的用户体验。\n","wordCount":"4804","inLanguage":"cn","datePublished":"2024-04-18T18:12:04+08:00","dateModified":"2024-04-18T18:12:04+08:00","author":{"@type":"Person","name":null},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chi-kai.github.io/post/gateway/"},"publisher":{"@type":"Organization","name":"悉达多","description":"成功只有一个:按照自己的方式，去度过人生\n","logo":{"@type":"ImageObject","url":"https://chi-kai.github.io/favicon.ico"}}}</script><title>网关限流的策略</title>
<link rel="stylesheet dns-prefetch preconnect preload prefetch" as=style media=screen href=https://chi-kai.github.io/css/style.min.65788784967ef394e528967eed8c63658368c6c4d417053ce77fd6c5ba25d364.css integrity="sha256-ZXiHhJZ+85TlKJZ+7YxjZYNoxsTUFwU853/Wxbol02Q=" crossorigin=anonymous></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://chi-kai.github.io/>悉达多</a></div><nav class="site-nav hide-in-mobile"><a href=https://chi-kai.github.io/post/>Posts</a><a href=https://chi-kai.github.io/tags/>Tags</a><a href=https://chi-kai.github.io/about/>About</a></nav></div><div class="hdr-right hdr-icons"><button id=menu-btn class=hdr-btn title><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://chi-kai.github.io/post/>Posts</a></li><li><a href=https://chi-kai.github.io/tags/>Tags</a></li><li><a href=https://chi-kai.github.io/about/>About</a></li></ul></div><main class="site-main section-inner thin animated fadeIn faster"><h1>网关限流的策略</h1><div class=content><p>最近在做一个基于 Pingora 的 AI 网关，限流是其中一个重要问题。在这里做一下记录</p><h2 id=为什么网关需要限流>为什么网关需要限流<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bd%91%e5%85%b3%e9%9c%80%e8%a6%81%e9%99%90%e6%b5%81 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>网关作为系统的入口，承担着连接客户端和后端服务的重要角色。限流机制在网关层面实现有以下几个关键原因：</p><ol><li><strong>保护后端服务</strong>：防止突发流量导致后端服务过载崩溃，确保系统稳定性</li><li><strong>资源合理分配</strong>：在有限资源条件下，确保资源被公平合理地分配给各个用户</li><li><strong>防止恶意攻击</strong>：限制单一来源的请求频率，有效防范 DDoS 等恶意攻击</li><li><strong>服务质量保障</strong>：通过限制总体流量，保证系统响应时间和服务质量</li><li><strong>成本控制</strong>：特别是对于 AI 服务，限流直接关系到 API 调用成本控制</li></ol><h2 id=常见限流算法>常见限流算法<a href=#%e5%b8%b8%e8%a7%81%e9%99%90%e6%b5%81%e7%ae%97%e6%b3%95 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>下面先解释几种常见的限流算法。固定窗口计数器，滑动窗口计数器，令牌桶算法，和 漏桶算法。</p><h3 id=固定窗口计数器fixed-window-counter>固定窗口计数器（Fixed Window Counter）<a href=#%e5%9b%ba%e5%ae%9a%e7%aa%97%e5%8f%a3%e8%ae%a1%e6%95%b0%e5%99%a8fixed-window-counter class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>固定窗口计数器是最简单直观的限流算法：</p><ul><li>将时间划分为固定长度的窗口（如 1 分钟、1 小时）</li><li>在每个窗口内维护一个计数器，记录请求数量</li><li>当计数器达到预设阈值时，拒绝后续请求</li><li>在新窗口开始时，计数器重置为零</li></ul><p>给出一个实现的示例代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#75af00>FixedWindowCounter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>window_size_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>  <span style=color:#75715e>// 窗口大小（毫秒）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>max_requests</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>,</span>    <span style=color:#75715e>// 窗口内最大请求数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>current_count</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>,</span>   <span style=color:#75715e>// 当前计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>window_start</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>    <span style=color:#75715e>// 当前窗口开始时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>FixedWindowCounter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>fn</span> <span style=color:#75af00>allow_request</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>current_time_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>)</span> -&gt; <span style=color:#00a8c8>bool</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查是否需要重置窗口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#111>current_time_ms</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>window_start</span> <span style=color:#f92672>+</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>window_size_ms</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>current_count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>window_start</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查是否允许请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>current_count</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>max_requests</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>current_count</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#00a8c8>true</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>false</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>优点：</strong> 实现简单，计算开销小，内存占用少，适合简单场景和单机部署。</p><p><strong>缺点：</strong> 最大的缺点是存在边界突刺问题，即在窗口边界可能出现瞬间流量翻倍的情况。比如用户在 12:00:59 发送 100 个请求，然后在 12:01:01 又发送 100 个请求，实际上 2 秒内发送了 200 个请求，远超期望的速率。</p><h3 id=滑动窗口计数器sliding-window>滑动窗口计数器（Sliding Window）<a href=#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e8%ae%a1%e6%95%b0%e5%99%a8sliding-window class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>滑动窗口算法通过更精细的时间划分，解决固定窗口的边界问题：</p><ul><li>将时间窗口细分为多个小格（bucket）</li><li>每个格子记录各自时间段内的请求数</li><li>窗口随时间推移，动态计算当前有效时间范围内的请求总数</li><li>当总数超过阈值时拒绝请求</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#75af00>SlidingWindow</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>window_size_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>       <span style=color:#75715e>// 窗口大小（毫秒）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>bucket_size_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>       <span style=color:#75715e>// 每个桶的大小（毫秒）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>max_requests</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>,</span>         <span style=color:#75715e>// 窗口内最大请求数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>buckets</span>: <span style=color:#111>Vec</span><span style=color:#f92672>&lt;</span><span style=color:#111>(</span><span style=color:#00a8c8>u64</span><span style=color:#111>,</span> <span style=color:#00a8c8>u32</span><span style=color:#111>)</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>  <span style=color:#75715e>// (桶开始时间, 请求数)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>SlidingWindow</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>fn</span> <span style=color:#75af00>allow_request</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>current_time_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>)</span> -&gt; <span style=color:#00a8c8>bool</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 移除过期的桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>expire_time</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span> <span style=color:#f92672>-</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>window_size_ms</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>buckets</span><span style=color:#111>.</span><span style=color:#111>retain</span><span style=color:#111>(</span><span style=color:#f92672>|</span><span style=color:#111>(</span><span style=color:#111>time</span><span style=color:#111>,</span> <span style=color:#111>_</span><span style=color:#111>)</span><span style=color:#f92672>|</span> <span style=color:#f92672>*</span><span style=color:#111>time</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>expire_time</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算当前总请求数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>total_requests</span>: <span style=color:#00a8c8>u32</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>buckets</span><span style=color:#111>.</span><span style=color:#111>iter</span><span style=color:#111>().</span><span style=color:#111>map</span><span style=color:#111>(</span><span style=color:#f92672>|</span><span style=color:#111>(</span><span style=color:#111>_</span><span style=color:#111>,</span> <span style=color:#111>count</span><span style=color:#111>)</span><span style=color:#f92672>|</span> <span style=color:#111>count</span><span style=color:#111>).</span><span style=color:#111>sum</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查是否允许请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#111>total_requests</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>max_requests</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 找到或创建当前时间对应的桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#00a8c8>let</span> <span style=color:#111>current_bucket_time</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span> <span style=color:#f92672>/</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>bucket_size_ms</span> <span style=color:#f92672>*</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>bucket_size_ms</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>if</span> <span style=color:#00a8c8>let</span> <span style=color:#111>Some</span><span style=color:#111>(</span><span style=color:#111>idx</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>buckets</span><span style=color:#111>.</span><span style=color:#111>iter</span><span style=color:#111>().</span><span style=color:#111>position</span><span style=color:#111>(</span><span style=color:#f92672>|</span><span style=color:#111>(</span><span style=color:#111>time</span><span style=color:#111>,</span> <span style=color:#111>_</span><span style=color:#111>)</span><span style=color:#f92672>|</span> <span style=color:#f92672>*</span><span style=color:#111>time</span> <span style=color:#f92672>==</span> <span style=color:#111>current_bucket_time</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>                <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>buckets</span><span style=color:#111>[</span><span style=color:#111>idx</span><span style=color:#111>].</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>                <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>buckets</span><span style=color:#111>.</span><span style=color:#111>push</span><span style=color:#111>((</span><span style=color:#111>current_bucket_time</span><span style=color:#111>,</span> <span style=color:#ae81ff>1</span><span style=color:#111>));</span>
</span></span><span style=display:flex><span>            <span style=color:#111>}</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#00a8c8>true</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>false</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>优点：</strong>: 避免边界突刺问题，能够较好地处理突发流量。</p><p><strong>缺点：</strong>: 实现复杂度高于固定窗口，内存占用较大，特别是在分布式环境中同步复杂度增加。</p><h3 id=令牌桶算法token-bucket>令牌桶算法（Token Bucket）<a href=#%e4%bb%a4%e7%89%8c%e6%a1%b6%e7%ae%97%e6%b3%95token-bucket class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>令牌桶算法是一种更灵活的限流方式：</p><ul><li>系统维护一个固定容量的令牌桶</li><li>以固定速率向桶中添加令牌（如每秒 10 个）</li><li>每个请求消耗一个或多个令牌</li><li>如果桶中令牌不足，请求被拒绝或等待</li><li>令牌桶可以存储一定数量的令牌，允许突发流量</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#75af00>TokenBucket</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>capacity</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>,</span>           <span style=color:#75715e>// 桶容量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>rate_per_ms</span>: <span style=color:#00a8c8>f64</span><span style=color:#111>,</span>        <span style=color:#75715e>// 每毫秒生成的令牌数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>tokens</span>: <span style=color:#00a8c8>f64</span><span style=color:#111>,</span>             <span style=color:#75715e>// 当前令牌数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>last_refill_time</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>   <span style=color:#75715e>// 上次填充令牌的时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>TokenBucket</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>fn</span> <span style=color:#75af00>allow_request</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>current_time_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span> <span style=color:#111>tokens_required</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>)</span> -&gt; <span style=color:#00a8c8>bool</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算从上次填充到现在应该添加的令牌数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>time_passed</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span> <span style=color:#f92672>-</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>last_refill_time</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>let</span> <span style=color:#111>new_tokens</span> <span style=color:#f92672>=</span> <span style=color:#111>time_passed</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f64</span> <span style=color:#f92672>*</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>rate_per_ms</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新当前令牌数，不超过容量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>tokens</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>tokens</span> <span style=color:#f92672>+</span> <span style=color:#111>new_tokens</span><span style=color:#111>).</span><span style=color:#111>min</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>capacity</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f64</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>last_refill_time</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查令牌是否足够
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>tokens</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>tokens_required</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f64</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>tokens</span> <span style=color:#f92672>-=</span> <span style=color:#111>tokens_required</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f64</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#00a8c8>true</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>false</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>优点：</strong>: 能够较好地处理突发流量，提供缓冲能力。基于资源消耗的差异化限流。</p><p><strong>缺点：</strong>: 实现复杂，时间精度要求高，影响限流精确性。分布式实现需要额外机制保证一致性。</p><h3 id=漏桶算法leaky-bucket>漏桶算法（Leaky Bucket）<a href=#%e6%bc%8f%e6%a1%b6%e7%ae%97%e6%b3%95leaky-bucket class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>漏桶算法提供了一种更为严格的速率控制方式：</p><ul><li>将请求比作水滴，放入上方开口的漏桶中</li><li>漏桶以固定速率出水（处理请求）</li><li>当桶满时，新请求被丢弃</li><li>无论输入速率如何变化，输出速率始终恒定</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#75af00>LeakyBucket</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>capacity</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>,</span>           <span style=color:#75715e>// 桶容量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>leak_rate_per_ms</span>: <span style=color:#00a8c8>f64</span><span style=color:#111>,</span>   <span style=color:#75715e>// 每毫秒处理的请求数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>water_level</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>,</span>        <span style=color:#75715e>// 当前水位（请求数）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>last_leak_time</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>     <span style=color:#75715e>// 上次漏水时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>LeakyBucket</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>fn</span> <span style=color:#75af00>allow_request</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>current_time_ms</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>)</span> -&gt; <span style=color:#00a8c8>bool</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算从上次漏水到现在应该处理的请求数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>time_passed</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span> <span style=color:#f92672>-</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>last_leak_time</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>let</span> <span style=color:#111>leaked</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>time_passed</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f64</span> <span style=color:#f92672>*</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>leak_rate_per_ms</span><span style=color:#111>)</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>u32</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新当前水位，不低于0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>water_level</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>water_level</span><span style=color:#111>.</span><span style=color:#111>saturating_sub</span><span style=color:#111>(</span><span style=color:#111>leaked</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>last_leak_time</span> <span style=color:#f92672>=</span> <span style=color:#111>current_time_ms</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查桶是否有空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>water_level</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>capacity</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>water_level</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#00a8c8>true</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>false</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>优点：</strong> 适合需要稳定出口速率的场景。</p><p><strong>缺点：</strong> 不允许突发流量，可能导致资源浪费。请求可能需要等待较长时间。</p><h3 id=算法选择和组合>算法选择和组合<a href=#%e7%ae%97%e6%b3%95%e9%80%89%e6%8b%a9%e5%92%8c%e7%bb%84%e5%90%88 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>在实际应用中，我们往往需要根据具体场景选择合适的限流算法，甚至将多种算法组合使用：</p><ol><li><strong>固定窗口</strong>：适用于简单场景和统计类需求</li><li><strong>滑动窗口</strong>：适用于需要平滑控制且资源充足的场景</li><li><strong>令牌桶</strong>：适用于允许突发流量但需要控制长期平均速率的场景</li><li><strong>漏桶</strong>：适用于需要严格控制出口速率的场景</li></ol><p>在 Charon AI 网关中，我们主要采用令牌桶和滑动窗口的组合策略，针对不同维度（用户、IP、服务）采用不同的算法，以实现最佳的限流效果。</p><h2 id=ai-网关相比传统网关的特殊性>AI 网关相比传统网关的特殊性<a href=#ai-%e7%bd%91%e5%85%b3%e7%9b%b8%e6%af%94%e4%bc%a0%e7%bb%9f%e7%bd%91%e5%85%b3%e7%9a%84%e7%89%b9%e6%ae%8a%e6%80%a7 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>AI 网关与传统 API 网关相比，具有一些独特的特性和挑战：</p><ol><li><strong>资源消耗差异大</strong>：AI 请求的资源消耗差异极大，例如大模型推理与小模型推理的计算资源需求可能相差 10 倍以上</li><li><strong>请求参数影响资源</strong>：输入 token 数量、上下文长度等参数直接影响资源消耗，需要参数级别的限流</li><li><strong>响应时间不确定</strong>：AI 模型的响应时间波动较大，需要更复杂的超时和重试策略</li><li><strong>多维度计费模型</strong>：AI 服务通常基于多种指标计费（如 token 数、请求数），限流需要考虑多维度</li><li><strong>服务质量敏感</strong>：用户对 AI 服务的响应时间和稳定性要求较高，需要更精细的限流策略</li></ol><h2 id=ai-网关的限流策略>AI 网关的限流策略<a href=#ai-%e7%bd%91%e5%85%b3%e7%9a%84%e9%99%90%e6%b5%81%e7%ad%96%e7%95%a5 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>基于上面的分析，AI 网关的限流策略可以分为两个主要方向：</p><ol><li><strong>用户侧限流</strong>：控制来自客户端的请求频率和总量，在 AI 网关的特殊性下，需要更复杂的限流策略，针对用户、IP、服务等多个维度进行限流。</li><li><strong>服务侧限流</strong>：管理发往后端 AI 服务提供商的请求频率，不同服务提供商的资源消耗和响应时间不同，需要不同的限流策略。比如 chatgpt 和 deepseek 的价格，响应时间，资源消耗都不同。</li></ol><p>这种双向限流机制既避免 Token 被滥用，也确保了用户资源的合理分配。</p><h2 id=用户侧限流>用户侧限流<a href=#%e7%94%a8%e6%88%b7%e4%be%a7%e9%99%90%e6%b5%81 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>当一个请求进入 AI 网关时，会经历以下限流检查流程：</p><ol><li><strong>请求预处理</strong>：解析请求头，提取 API 密钥、IP 地址、请求路径等信息</li><li><strong>多维度限流检查</strong>：<ul><li><strong>API 密钥限流</strong>：检查该密钥的请求频率和总量是否超限</li><li><strong>IP 限流</strong>：检查源 IP 地址的请求频率是否超限,防止单一 IP 发送过多请求</li><li><strong>请求特征限流</strong>：基于请求参数（如模型类型、上下文长度）进行限流判断,对某些高消耗的端点（如长上下文模型请求）设置更严格的限制</li></ul></li><li><strong>限流决策</strong>：<ul><li>如果任一维度超限，返回 429 状态码，并附带 Retry-After 头</li><li>如果接近限制但未超限，可能进入排队机制</li><li>如果未超限，请求继续处理</li></ul></li><li><strong>计数更新</strong>：请求通过限流检查后，更新相应维度的计数器</li><li><strong>请求处理</strong>：将请求转发到后端 AI 服务</li></ol><p>整个流程的核心是确保在请求实际处理前就完成限流决策，避免资源浪费。</p><h3 id=分布式计数器系统>分布式计数器系统<a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e8%ae%a1%e6%95%b0%e5%99%a8%e7%b3%bb%e7%bb%9f class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>用户侧限流的核心是分布式计数器系统，它负责在分布式环境中准确追踪各维度的请求数量。</p><h4 id=架构设计>架构设计<a href=#%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>我们采用二级架构实现分布式计数器：</p><ol><li><p><strong>Redis 作为共享计数存储</strong></p><ul><li>使用 Redis 的原子操作特性确保计数准确性</li><li>键设计采用 <code>{user_id}:{resource_type}:{time_window}:{timestamp}</code> 格式, 比如 <code>user1:token:60:1708222400</code></li><li>实现自动过期机制，避免存储膨胀</li></ul></li><li><p><strong>本地内存缓存层</strong></p><ul><li>每个网关实例维护本地计数缓存，减少网络请求</li><li>定期与 Redis 同步，确保数据一致性</li><li>使用 LRU 策略管理缓存大小</li></ul></li></ol><h4 id=滑动窗口实现>滑动窗口实现<a href=#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%ae%9e%e7%8e%b0 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>示例场景: 限制用户每分钟最多 100 次请求。传统固定窗口可能在窗口边界出现"突刺"，比如用户在 12:00:59 发送 100 个请求，然后在 12:01:01 又发送 100 个请求，实际上 2 秒内发送了 200 个请求，远超期望的速率。</p><p>我们的滑动窗口算法这样工作：</p><ol><li>把每分钟分成更小的时间桶，比如 6 个 10 秒的桶</li><li>每个请求进来时，更新当前时间桶的计数</li><li>计算窗口限制时，汇总当前时间往前推一个完整窗口内的所有桶的计数</li></ol><p>具体代码逻辑类似这样：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>fn</span> <span style=color:#75af00>check_and_increment</span><span style=color:#111>(</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>user_id</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>window_size_secs</span>: <span style=color:#00a8c8>u64</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>limit</span>: <span style=color:#00a8c8>u64</span>
</span></span><span style=display:flex><span><span style=color:#111>)</span> -&gt; <span style=color:#111>Result</span><span style=color:#f92672>&lt;</span><span style=color:#00a8c8>bool</span><span style=color:#111>,</span> <span style=color:#111>Error</span><span style=color:#f92672>&gt;</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>now</span> <span style=color:#f92672>=</span> <span style=color:#111>SystemTime</span>::<span style=color:#111>now</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>duration_since</span><span style=color:#111>(</span><span style=color:#00a8c8>UNIX_EPOCH</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>unwrap</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>as_secs</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算当前桶的起始时间（以10秒为一个桶）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>bucket_size</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>current_bucket</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>now</span> <span style=color:#f92672>/</span> <span style=color:#111>bucket_size</span><span style=color:#111>)</span> <span style=color:#f92672>*</span> <span style=color:#111>bucket_size</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算窗口内所有需要检查的桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>window_start</span> <span style=color:#f92672>=</span> <span style=color:#111>now</span> <span style=color:#f92672>-</span> <span style=color:#111>window_size_secs</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#00a8c8>mut</span> <span style=color:#111>all_buckets</span> <span style=color:#f92672>=</span> <span style=color:#111>Vec</span>::<span style=color:#111>new</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 收集所有桶（整个窗口时间范围内）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#00a8c8>mut</span> <span style=color:#111>bucket</span> <span style=color:#f92672>=</span> <span style=color:#111>current_bucket</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>while</span> <span style=color:#111>bucket</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>window_start</span> <span style=color:#f92672>/</span> <span style=color:#111>bucket_size</span> <span style=color:#f92672>*</span> <span style=color:#111>bucket_size</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>all_buckets</span><span style=color:#111>.</span><span style=color:#111>push</span><span style=color:#111>(</span><span style=color:#111>bucket</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>bucket</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>bucket_size</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>bucket</span> <span style=color:#f92672>-=</span> <span style=color:#111>bucket_size</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>break</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用Redis pipeline批量获取所有桶的计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#00a8c8>mut</span> <span style=color:#111>pipe</span> <span style=color:#f92672>=</span> <span style=color:#111>redis</span>::<span style=color:#111>pipe</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>keys</span>: <span style=color:#111>Vec</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#111>all_buckets</span><span style=color:#111>.</span><span style=color:#111>iter</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>map</span><span style=color:#111>(</span><span style=color:#f92672>|</span><span style=color:#111>b</span><span style=color:#f92672>|</span> <span style=color:#111>format!</span><span style=color:#111>(</span><span style=color:#d88200>&#34;rate:</span><span style=color:#d88200>{}</span><span style=color:#d88200>:</span><span style=color:#d88200>{}</span><span style=color:#d88200>:</span><span style=color:#d88200>{}</span><span style=color:#d88200>&#34;</span><span style=color:#111>,</span> <span style=color:#111>user_id</span><span style=color:#111>,</span> <span style=color:#111>window_size_secs</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>))</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>collect</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>for</span> <span style=color:#111>key</span> <span style=color:#00a8c8>in</span> <span style=color:#f92672>&amp;</span><span style=color:#111>keys</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>pipe</span><span style=color:#111>.</span><span style=color:#111>get</span><span style=color:#111>(</span><span style=color:#111>key</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>counts</span>: <span style=color:#111>Vec</span><span style=color:#f92672>&lt;</span><span style=color:#111>Option</span><span style=color:#f92672>&lt;</span><span style=color:#00a8c8>u64</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>=</span> <span style=color:#111>pipe</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>query</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>redis_conn</span><span style=color:#111>)</span><span style=color:#f92672>?</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算总请求数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>total_count</span>: <span style=color:#00a8c8>u64</span> <span style=color:#f92672>=</span> <span style=color:#111>counts</span><span style=color:#111>.</span><span style=color:#111>iter</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>filter_map</span><span style=color:#111>(</span><span style=color:#f92672>|</span><span style=color:#111>c</span><span style=color:#f92672>|</span> <span style=color:#f92672>*</span><span style=color:#111>c</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>sum</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断是否超限
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>if</span> <span style=color:#111>total_count</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>limit</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>Ok</span><span style=color:#111>(</span><span style=color:#00a8c8>false</span><span style=color:#111>);</span> <span style=color:#75715e>// 已达到限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 未超限，递增当前桶的计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>current_key</span> <span style=color:#f92672>=</span> <span style=color:#111>format!</span><span style=color:#111>(</span><span style=color:#d88200>&#34;rate:</span><span style=color:#d88200>{}</span><span style=color:#d88200>:</span><span style=color:#d88200>{}</span><span style=color:#d88200>:</span><span style=color:#d88200>{}</span><span style=color:#d88200>&#34;</span><span style=color:#111>,</span> <span style=color:#111>user_id</span><span style=color:#111>,</span> <span style=color:#111>window_size_secs</span><span style=color:#111>,</span> <span style=color:#111>current_bucket</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 原子递增并设置过期时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>_</span>: <span style=color:#111>()</span> <span style=color:#f92672>=</span> <span style=color:#111>redis</span>::<span style=color:#111>pipe</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>atomic</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>incr</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>current_key</span><span style=color:#111>,</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>expire</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>current_key</span><span style=color:#111>,</span> <span style=color:#111>window_size_secs</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>usize</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>60</span><span style=color:#111>)</span> <span style=color:#75715e>// 窗口大小+额外余量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>.</span><span style=color:#111>query</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>redis_conn</span><span style=color:#111>)</span><span style=color:#f92672>?</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#111>Ok</span><span style=color:#111>(</span><span style=color:#00a8c8>true</span><span style=color:#111>)</span> <span style=color:#75715e>// 未达到限制，允许请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span></code></pre></div><h3 id=api-密钥限流>API 密钥限流<a href=#api-%e5%af%86%e9%92%a5%e9%99%90%e6%b5%81 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>API 密钥限流是用户侧限流的第一道防线，针对已认证用户进行资源分配和使用控制。</p><h4 id=多级限流策略>多级限流策略<a href=#%e5%a4%9a%e7%ba%a7%e9%99%90%e6%b5%81%e7%ad%96%e7%95%a5 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>我们实现了多级限流策略：</p><ol><li><strong>短期速率限制</strong>：控制每秒/每分钟的请求数量（QPS/QPM），使用上面的滑动窗口算法实现</li><li><strong>长期配额限制</strong>：控制每日/每月的总请求量或 token 消耗量，使用上面的分布式计数器实现</li><li><strong>差异化模型限制</strong>：不同模型类型设置不同的限制阈值，使用差异化的分布式计数器实现</li></ol><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>struct</span> <span style=color:#75af00>ApiKeyRateLimiter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>redis_client</span>: <span style=color:#75af00>Arc</span><span style=color:#f92672>&lt;</span><span style=color:#111>RedisClient</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>local_cache</span>: <span style=color:#75af00>Mutex</span><span style=color:#f92672>&lt;</span><span style=color:#111>LruCache</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#111>,</span> <span style=color:#00a8c8>u32</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>user_limits</span>: <span style=color:#75af00>HashMap</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#111>,</span> <span style=color:#111>UserLimits</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>ApiKeyRateLimiter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>fn</span> <span style=color:#75af00>check_limit</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>api_key</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span> <span style=color:#111>model</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span> <span style=color:#111>request_size</span>: <span style=color:#00a8c8>usize</span><span style=color:#111>)</span> -&gt; <span style=color:#75af00>LimitResult</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 检查短期速率限制（QPS）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#f92672>!</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_qps_limit</span><span style=color:#111>(</span><span style=color:#111>api_key</span><span style=color:#111>,</span> <span style=color:#111>model</span><span style=color:#111>).</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#00a8c8>false</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>LimitResult</span>::<span style=color:#111>RateLimited</span><span style=color:#111>(</span><span style=color:#ae81ff>5</span><span style=color:#111>);</span> <span style=color:#75715e>// 建议 5 秒后重试
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. 检查长期配额限制（每日总量）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#f92672>!</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_daily_quota</span><span style=color:#111>(</span><span style=color:#111>api_key</span><span style=color:#111>,</span> <span style=color:#111>request_size</span><span style=color:#111>).</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#00a8c8>false</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>LimitResult</span>::<span style=color:#111>QuotaExceeded</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. 检查模型特定限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#f92672>!</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_model_specific_limit</span><span style=color:#111>(</span><span style=color:#111>api_key</span><span style=color:#111>,</span> <span style=color:#111>model</span><span style=color:#111>,</span> <span style=color:#111>request_size</span><span style=color:#111>).</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#00a8c8>false</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>LimitResult</span>::<span style=color:#111>ModelLimited</span><span style=color:#111>(</span><span style=color:#ae81ff>10</span><span style=color:#111>);</span> <span style=color:#75715e>// 建议 10 秒后重试
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过所有限制检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>LimitResult</span>::<span style=color:#111>Allowed</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>fn</span> <span style=color:#75af00>check_daily_quota</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>api_key</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span> <span style=color:#111>request_size</span>: <span style=color:#00a8c8>usize</span><span style=color:#111>)</span> -&gt; <span style=color:#111>Result</span><span style=color:#f92672>&lt;</span><span style=color:#00a8c8>bool</span><span style=color:#111>,</span> <span style=color:#111>Error</span><span style=color:#f92672>&gt;</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 获取当前日期的时间戳（按天计算）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>now</span> <span style=color:#f92672>=</span> <span style=color:#111>SystemTime</span>::<span style=color:#111>now</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>duration_since</span><span style=color:#111>(</span><span style=color:#00a8c8>UNIX_EPOCH</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>unwrap</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>as_secs</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>day_timestamp</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>now</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>86400</span><span style=color:#111>)</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>86400</span><span style=color:#111>;</span> <span style=color:#75715e>// 取当天的起始时间戳（86400 = 24小时的秒数）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 构造Redis键，格式为 &#34;quota:{api_key}:daily:{day_timestamp}&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>quota_key</span> <span style=color:#f92672>=</span> <span style=color:#111>format!</span><span style=color:#111>(</span><span style=color:#d88200>&#34;quota:</span><span style=color:#d88200>{}</span><span style=color:#d88200>:daily:</span><span style=color:#d88200>{}</span><span style=color:#d88200>&#34;</span><span style=color:#111>,</span> <span style=color:#111>api_key</span><span style=color:#111>,</span> <span style=color:#111>day_timestamp</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 获取用户的每日配额限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>user_id</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>get_user_id_from_api_key</span><span style=color:#111>(</span><span style=color:#111>api_key</span><span style=color:#111>)</span><span style=color:#f92672>?</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>daily_limit</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>user_limits</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>get</span><span style=color:#111>(</span><span style=color:#111>user_id</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>map</span><span style=color:#111>(</span><span style=color:#f92672>|</span><span style=color:#111>limits</span><span style=color:#f92672>|</span> <span style=color:#111>limits</span><span style=color:#111>.</span><span style=color:#111>daily_quota</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#00a8c8>DEFAULT_DAILY_QUOTA</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 原子操作：检查当前用量并增加请求大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#00a8c8>mut</span> <span style=color:#111>conn</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>redis_client</span><span style=color:#111>.</span><span style=color:#111>get_connection</span><span style=color:#111>()</span><span style=color:#f92672>?</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>current_usage</span>: <span style=color:#00a8c8>u64</span> <span style=color:#f92672>=</span> <span style=color:#111>conn</span><span style=color:#111>.</span><span style=color:#111>get</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>quota_key</span><span style=color:#111>).</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 判断是否超出配额
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>if</span> <span style=color:#111>current_usage</span> <span style=color:#f92672>+</span> <span style=color:#111>request_size</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>u64</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>daily_limit</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>Ok</span><span style=color:#111>(</span><span style=color:#00a8c8>false</span><span style=color:#111>);</span> <span style=color:#75715e>// 配额已用尽
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6. 未超出配额，增加用量并设置过期时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>_</span>: <span style=color:#111>()</span> <span style=color:#f92672>=</span> <span style=color:#111>redis</span>::<span style=color:#111>pipe</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>atomic</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>incr</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>quota_key</span><span style=color:#111>,</span> <span style=color:#111>request_size</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>u64</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>.</span><span style=color:#111>expire</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>quota_key</span><span style=color:#111>,</span> <span style=color:#ae81ff>86400</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3600</span><span style=color:#111>)</span> <span style=color:#75715e>// 设置为1天+1小时（额外余量防止边界问题）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>.</span><span style=color:#111>query</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#00a8c8>mut</span> <span style=color:#111>conn</span><span style=color:#111>)</span><span style=color:#f92672>?</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#111>Ok</span><span style=color:#111>(</span><span style=color:#00a8c8>true</span><span style=color:#111>)</span> <span style=color:#75715e>// 未达到限制，允许请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span></code></pre></div><h3 id=ip-地址限流>IP 地址限流<a href=#ip-%e5%9c%b0%e5%9d%80%e9%99%90%e6%b5%81 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>IP 限流主要用于防止恶意攻击和保护未认证请求路径，是系统安全的重要保障。</p><h4 id=自适应阈值>自适应阈值<a href=#%e8%87%aa%e9%80%82%e5%ba%94%e9%98%88%e5%80%bc class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>我们实现了基于历史流量模式的自适应阈值：</p><ol><li><strong>基础限制</strong>：所有 IP 都有默认的基础请求限制</li><li><strong>信誉系统</strong>：根据 IP 的历史行为动态调整限制</li><li><strong>异常检测</strong>：识别异常流量模式，对可疑 IP 实施更严格限制</li></ol><h4 id=代码实现>代码实现<a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>struct</span> <span style=color:#75af00>IpRateLimiter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>redis_client</span>: <span style=color:#75af00>Arc</span><span style=color:#f92672>&lt;</span><span style=color:#111>RedisClient</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>suspicious_ip_bloom</span>: <span style=color:#75af00>BloomFilter</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>ip_reputation</span>: <span style=color:#75af00>HashMap</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#111>,</span> <span style=color:#00a8c8>f32</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>IpRateLimiter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>fn</span> <span style=color:#75af00>check_limit</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>ip_address</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span> <span style=color:#111>limit</span>: <span style=color:#00a8c8>u32</span><span style=color:#111>)</span> -&gt; <span style=color:#111>Result</span><span style=color:#f92672>&lt;</span><span style=color:#00a8c8>bool</span><span style=color:#111>,</span> <span style=color:#111>Error</span><span style=color:#f92672>&gt;</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 预筛选：检查是否为可疑 IP（根据历史数据）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>if</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>suspicious_ip_bloom</span><span style=color:#111>.</span><span style=color:#111>might_contain</span><span style=color:#111>(</span><span style=color:#111>ip_address</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 对可疑 IP 使用更严格的限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#00a8c8>let</span> <span style=color:#111>strict_limit</span> <span style=color:#f92672>=</span> <span style=color:#111>limit</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_rate</span><span style=color:#111>(</span><span style=color:#111>ip_address</span><span style=color:#111>,</span> <span style=color:#111>strict_limit</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据 IP 信誉调整限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>reputation_factor</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>ip_reputation</span><span style=color:#111>.</span><span style=color:#111>get</span><span style=color:#111>(</span><span style=color:#111>ip_address</span><span style=color:#111>).</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1.0</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>let</span> <span style=color:#111>adjusted_limit</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>limit</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f32</span> <span style=color:#f92672>*</span> <span style=color:#111>reputation_factor</span><span style=color:#111>)</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>u32</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_rate</span><span style=color:#111>(</span><span style=color:#111>ip_address</span><span style=color:#111>,</span> <span style=color:#111>adjusted_limit</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><h3 id=请求特征限流>请求特征限流<a href=#%e8%af%b7%e6%b1%82%e7%89%b9%e5%be%81%e9%99%90%e6%b5%81 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>请求特征限流是 AI 网关特有的限流维度，针对请求参数和资源消耗进行精细控制。</p><h4 id=差异化限流策略>差异化限流策略<a href=#%e5%b7%ae%e5%bc%82%e5%8c%96%e9%99%90%e6%b5%81%e7%ad%96%e7%95%a5 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>我们基于以下特征实施差异化限流：</p><ol><li><strong>模型差异化限流</strong>：不同模型设置不同 QPS 限制（如 GPT-4 限制为 5 QPS，GPT-3.5 为 20 QPS）</li><li><strong>参数敏感限流</strong>：大 context_length 请求（如 16K tokens）设置更严格限制</li><li><strong>端点差异化</strong>：不同 API 端点（如聊天补全、嵌入）设置不同限制</li></ol><h4 id=代码实现-1>代码实现<a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>struct</span> <span style=color:#75af00>RequestFeatureLimiter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>model_limits</span>: <span style=color:#75af00>HashMap</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#111>,</span> <span style=color:#111>ModelLimits</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#111>endpoint_limits</span>: <span style=color:#75af00>HashMap</span><span style=color:#f92672>&lt;</span><span style=color:#111>String</span><span style=color:#111>,</span> <span style=color:#00a8c8>u32</span><span style=color:#f92672>&gt;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>impl</span> <span style=color:#111>RequestFeatureLimiter</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>fn</span> <span style=color:#75af00>check_limit</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#111>api_key</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#111>model</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#111>endpoint</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#111>context_length</span>: <span style=color:#00a8c8>usize</span><span style=color:#111>)</span> -&gt; <span style=color:#75af00>LimitResult</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 检查模型特定限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>model_limit</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>model_limits</span><span style=color:#111>.</span><span style=color:#111>get</span><span style=color:#111>(</span><span style=color:#111>model</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>            <span style=color:#111>.</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>model_limits</span><span style=color:#111>[</span><span style=color:#d88200>&#34;default&#34;</span><span style=color:#111>]);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. 检查上下文长度限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>length_factor</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>if</span> <span style=color:#111>context_length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>8192</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0.5</span>  <span style=color:#75715e>// 大上下文请求限制更严格
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#00a8c8>if</span> <span style=color:#111>context_length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>4096</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0.75</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>        <span style=color:#111>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. 检查端点限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>endpoint_limit</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>endpoint_limits</span><span style=color:#111>.</span><span style=color:#111>get</span><span style=color:#111>(</span><span style=color:#111>endpoint</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>            <span style=color:#111>.</span><span style=color:#111>unwrap_or</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>endpoint_limits</span><span style=color:#111>[</span><span style=color:#d88200>&#34;default&#34;</span><span style=color:#111>]);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 综合判断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>effective_limit</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>model_limit</span><span style=color:#111>.</span><span style=color:#111>qps</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>f32</span> <span style=color:#f92672>*</span> <span style=color:#111>length_factor</span><span style=color:#111>)</span> <span style=color:#00a8c8>as</span> <span style=color:#00a8c8>u32</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>effective_limit</span> <span style=color:#f92672>&lt;</span> <span style=color:#f92672>*</span><span style=color:#111>endpoint_limit</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用更严格的限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_rate</span><span style=color:#111>(</span><span style=color:#111>api_key</span><span style=color:#111>,</span> <span style=color:#111>model</span><span style=color:#111>,</span> <span style=color:#111>effective_limit</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>check_rate</span><span style=color:#111>(</span><span style=color:#111>api_key</span><span style=color:#111>,</span> <span style=color:#111>endpoint</span><span style=color:#111>,</span> <span style=color:#f92672>*</span><span style=color:#111>endpoint_limit</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><h3 id=智能排队机制>智能排队机制<a href=#%e6%99%ba%e8%83%bd%e6%8e%92%e9%98%9f%e6%9c%ba%e5%88%b6 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>为了提高用户体验，我们实现了智能排队机制，在短期速率超限但资源允许的情况下，不直接拒绝请求而是进行排队处理。</p><h4 id=排队策略>排队策略<a href=#%e6%8e%92%e9%98%9f%e7%ad%96%e7%95%a5 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><ol><li><strong>优先级排队</strong>：基于用户等级和请求重要性确定队列优先级</li><li><strong>超时控制</strong>：设置最大等待时间，避免资源无限占用</li><li><strong>动态调整</strong>：根据系统负载动态调整队列处理速度</li></ol><h4 id=代码实现-2>代码实现<a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#00a8c8>pub</span> <span style=color:#00a8c8>fn</span> <span style=color:#75af00>handle_request_burst</span><span style=color:#111>(</span><span style=color:#f92672>&amp;</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>user_id</span>: <span style=color:#00a8c8>&amp;</span><span style=color:#00a8c8>str</span><span style=color:#111>,</span> <span style=color:#111>request</span>: <span style=color:#75af00>Request</span><span style=color:#111>)</span> -&gt; <span style=color:#75af00>Response</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查用户当前使用量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>let</span> <span style=color:#111>usage</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>get_current_usage</span><span style=color:#111>(</span><span style=color:#111>user_id</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>let</span> <span style=color:#111>limit</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>get_user_limit</span><span style=color:#111>(</span><span style=color:#111>user_id</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>if</span> <span style=color:#111>usage</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>limit</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 完全超限，直接拒绝
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>return</span> <span style=color:#111>Response</span>::<span style=color:#111>rate_limited</span><span style=color:#111>(</span><span style=color:#ae81ff>429</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;Rate limit exceeded&#34;</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#00a8c8>if</span> <span style=color:#111>usage</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>limit</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.8</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 接近限制，尝试排队
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>let</span> <span style=color:#111>priority</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>get_user_priority</span><span style=color:#111>(</span><span style=color:#111>user_id</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>let</span> <span style=color:#111>wait_time</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>queue_manager</span><span style=color:#111>.</span><span style=color:#111>enqueue</span><span style=color:#111>(</span><span style=color:#111>request</span><span style=color:#111>,</span> <span style=color:#111>priority</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>wait_time</span> <span style=color:#f92672>&gt;</span> <span style=color:#00a8c8>MAX_WAIT_TIME</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 等待时间过长，拒绝请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#00a8c8>return</span> <span style=color:#111>Response</span>::<span style=color:#111>rate_limited</span><span style=color:#111>(</span><span style=color:#ae81ff>429</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;Queue too long&#34;</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 请求进入队列，等待处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>return</span> <span style=color:#111>Response</span>::<span style=color:#111>queued</span><span style=color:#111>(</span><span style=color:#ae81ff>202</span><span style=color:#111>,</span> <span style=color:#111>wait_time</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 未超限，正常处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>self</span><span style=color:#111>.</span><span style=color:#111>process_request</span><span style=color:#111>(</span><span style=color:#111>request</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><h2 id=服务侧限流>服务侧限流<a href=#%e6%9c%8d%e5%8a%a1%e4%be%a7%e9%99%90%e6%b5%81 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>服务侧限流是管理发往后端 AI 服务提供商的请求频率，不同服务提供商的资源消耗和响应时间不同，需要不同的限流策略。</p><h2 id=多实例协同>多实例协同<a href=#%e5%a4%9a%e5%ae%9e%e4%be%8b%e5%8d%8f%e5%90%8c class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>在分布式部署环境中，多个网关实例需要协同工作，确保限流的一致性和准确性。</p><h4 id=协同机制>协同机制<a href=#%e5%8d%8f%e5%90%8c%e6%9c%ba%e5%88%b6 class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><ol><li><strong>计数同步</strong>：使用 Redis 作为中央存储，确保计数一致性</li><li><strong>配置共享</strong>：限流配置统一存储，所有实例实时获取最新配置</li><li><strong>状态广播</strong>：关键状态变更（如紧急限流）通过发布订阅机制广播</li></ol><p>通过以上机制，我们实现了高性能、高可靠的用户侧限流系统，既保障了系统的稳定性，又提供了良好的用户体验。</p></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2025 <a href=https://chi-kai.github.io/>悉达多</a>
&#183; &#183; Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>
&#183; Theme <a href=https://github.com/1bl4z3r/hermit-V2 target=_blank rel=noopener>Hermit-V2</a></p></footer><script async src=https://chi-kai.github.io/js/bundle.min.c7c384e4d29d192bbac6811ae4660bb01767194a5bea56baca77e8260f93ea16.js integrity="sha256-x8OE5NKdGSu6xoEa5GYLsBdnGUpb6la6ynfoJg+T6hY=" crossorigin=anonymous></script><script id=MathJax-script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js crossorigin=anonymous></script><script type=text/javascript id=MathJax-script-helper async src=https://chi-kai.github.io/js/mathjax-assistant.min.ca29e9d446b2a6cb6c6e3eb0d47e9693f5c306c146eaccb43047afbf31b07a6f.js integrity="sha256-yinp1Eaypstsbj6w1H6Wk/XDBsFG6sy0MEevvzGwem8=" crossorigin=anonymous></script></body></html>