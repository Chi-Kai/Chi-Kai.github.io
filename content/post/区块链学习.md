---
title: "区块链学习---BTC"
date: 2022-11-28T11:08:17+08:00
draft: true
---

# BTC 

bitcoin 的论文标题为 一种点对点的电子现金系统，可见它最初的设计目标是为了摆脱第三方中介，建立一个新型的信任模型。是区块链技术第一次实际运用。

## 密码学原理

### 哈希

- **collision resistance** (这里指哈希碰撞) : 
  
	例如 x≠y H(x)=H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。
	
	给出x，很难找到y，除非蛮力求解(brute-force)。

	该性质的作用:对一个message求digest

	比如message取m m的哈希值是H(m)=digest 如果有人想篡改m值而H(m)不变，则无法做到。

	collision resistance无法验证，是根据实践经验得来的。

- **hiding** : 
  
	哈希函数的计算过程是单向的，不可逆的。无法从哈希值推出输入内容。

	前提是**输入空间足够大，分布均匀**。否则可能被蛮力破解。可以在输入后面拼接一个随机数来取hash,保证输入足够大。

	该性质的作用:和collision resistance 结合在一起，用来实现**digital commitment**(又称为digital equivalent of a sealed envelope)。把预测结果作为输入x，算出一个哈希值，将哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。 

- **puzzle friendly** :
  
	哈希值事先不可预测，仅仅根据输入很难预测输出。在比特币中采用SHA-256哈希函数，需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。该性质保证了比特币系统中，只能通过“挖矿”获得比特币。也就是说，该性质保证了工作量证明(POW)机制可以运行下去【“挖矿难，但验证易”】。

### 签名

比特币中账户管理 在第三方中心化系统中，账户开通依赖于第三方。但去中心化的比特币系统中，很明显不能
进行“申请账户”。在比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对。（关于公私
钥请自行了解非对称加密体系和对称加密体系） 公钥和私钥的应用保证了“签名”的应用。当在比特币网络中进
行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。 在发布交
易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。也就是说，只有拥有
私钥，才能将该账户中的比特币转走。 【注意：比特币系统中，很难通过生成大量公私钥对来获取他人私钥】

## 数据结构

### hash pointer (哈希指针)

![](https://s2.loli.net/2022/11/28/8ReVK2i7LQqWsld.png)

从上图可以看出每个区块包含**一个时间戳、一个随机数、一个对上一个区块的引用（即哈希）和上一区块生成以来发生的所有交易列表**。 随着时间推移就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。

区块链上的区块（除了创世区块）都有一个hash pointer指向前一个区块，通过前一个区块整体来获取一个hash。如果一个区块被恶意修改，则后面的区块hash都会无法匹配。

区块链系统中有的节点只需保存部分区块，等到需要其他区块时，再向其他节点获取，可以通过hash来验证正确性。

### Merkle tree

![](https://s2.loli.net/2022/11/28/fKRoqOe94NlCHLj.png)

比特币一个重要的可扩展特性是：它的区块存储在多层次数据结构中。 一个区块的哈希实际上只是区块头的哈希，区块头是一段约 200 字节的数据，包含时间戳、随机数、上个区块的哈希和默克尔树根的哈希，而默克尔树是一个存储了该区块所有交易的数据结构。

默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面是大量包含基础数据的叶节点，**每个中间节点是其两个子节点的哈希**，顶部的根节点也是其两个子节点的哈希。 默克尔树的目的是允许区块数据可以零散地传送：**节点可以从一个源下载区块头，从其它源下载相关树的一小部分，而依然能够确认所有的数据都是正确的**。

简化支付确认协议（SPV）允许另一种节点存在，这样的节点被称为“轻节点”，它下载区块头，使用区块头确认工作量证明，**然后只下载与其交易相关的默克尔树分支**。 这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和帐户的当前余额。

## 协议

### double spending attack

数字货币本身为带有签名的数据文件，可以进行复制。即：对用户来说，可以将同一货币花费两次。

对货币添加唯一编号（不可篡改），每次支付向货币发行单位查询真伪。 该方法每次交易都需要依赖于
第三方机构来判断货币真伪且防止双花攻击。是一个典型的第三方中心化方案。

而比特币系统中是通过挖矿来决定货币的发行权和发行量，通过系统维护的区块链结构来解决双花问题

### 分布式共识

为了保证区块链内容在不同节点上的一致性，需要取得分布式共识。

FLP不可能结论: 在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。

CAP（Consistency一致性、Availability可靠性、Partition tolerance容错性） Theorem: 任何一个分布式系统
中，最多只能满足其中两个性质。 分布式共识中协议Paxos 可以保证Consistency（若达成共识必然一致），但在某
些情况下，可能会一直无法达成共识。

假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识
协议设置。 想法1：直接投票某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查
若正确投赞成票，若票数过半数，加入区块链。 
  - 存在的问题1——恶意节点不断打包不合法区块，导致一直无
法达成共识，时间全花费在投票上。 
  - 存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。 
  - 存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。 
  - 更大的一个问题——membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得
支配地位（**女巫攻击**）。

所以，这种简单的投票方案也是不可行的。

比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。 在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。[H(block header)<=target] 当某个节点找到符合要求的nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。

  - 可能出现分叉情况。当两个节点同时获得记账权，这时就会出现分叉，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。这样，也就会导致合法区块被拒绝

  - 分叉攻击。A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都
合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。 在比特
币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下
去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要
达到整个系统中51%的计算力，才能使得这种攻击成功

### 激励机制

节点竞争记账权需要消耗算力和电力成本，为了让激励节点参与，系统会给出块节点 **出块奖励**，一个获得
合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。

比特币系统设计规定，起初每个区块可以获得50个比特币，但之后**每隔21万个区块**，奖励减半。因为平均出块时间为10分钟，可以算出大约**四年**减半。

区块中保存交易记录，如果仅仅设置出块奖励，那么，会不会存在节点只想发布区块获得出块奖励而不想打包交易？

BTC系统设计了**Tranction fee（交易费）**，每个交易可以有多个输入，也可以有多个输出，但输入之和要等于输出之和（total inputs = total outputs）。 存在一些交易的total inputs 略大于 total outputs，这部分差额便作为交易费，给了获得记账权的节点。对于获得记账权节点来说，除了出块奖励之外，还可以得到打包交易的交易费。但目前来说，交易费远远小于出块奖励。等到未来出块奖励变少，可能区块链的维护便主要依赖于交易费了。


## 实现

### UTXO

比特币采用了 **基于交易的账本模式** 。然而，系统中并无显示记录账户包含比特币数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为 **UTXO**(Unspent Transaction Output尚未被花掉的交易输出) 的数据结构。

A转给B五个BTC，转给C3个BTC，B将5个BTC花掉，则该交易记录不保存在UTXO中，C没有花掉，则该交易记录保存在UTXO中

UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可
以定位到UTXO中的输出。

> 判断一个交易是否合法，要查一下想要花掉的BTC是否在该集合中，只有在集合中才是合法的。如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么根本不存在，要么已经被花过。所以，全节点需要在内存中维护一个UTXO，从而便于快速检测double spending（双花攻击）。



## 网络

![](https://s2.loli.net/2022/12/01/gzeoK1dSaJf4VRL.png)

bitcoin 网络层使用的是p2p网络，区块链运行在应用层。

节点之间的通信采用了TCP协议，便于穿透防火墙。

当一个节点要加入网络时，要先找到一个seed node (种子节点)，通过这个种子节点来获得其他节点。退出时自行退出，过段时间其他节点就会把它从网络中删除。

网络设计原则: **simple,robust,but not efficient**

节点维护一个收到的待上链的交易集合，当第一次收到一个交易时，会转发给邻居节点并加入集合，下次收到时就不会转发。当交易上链就把它删掉。

假如网络中存在两个冲突交易，如
交易1：A->B,交易2：A->C（假设花费的同一笔钱）。具体接收哪个取决于节点先接收到哪个交易，之后收到另一个
交易会将其放弃。

新发布区块在网络中传播方式与新发布交易传播方式类似，每个节点除检查该区块内容是否合法，还要检查是否位于
最长合法链上。区块越大，则网络上传输越慢。BTC协议对于区块大小限制为不大于1M大小.

此外，比特币网络传播属于 Best effort（尽力而为） ，不能保证一定传输成功。以一个交易发布到网络上，未必所
有节点都能收到，也未必所有节点收到交易顺序都一致。

## 挖矿

![](https://s2.loli.net/2022/12/02/84z1iTa5Qk3CgLd.png)

![](https://s2.loli.net/2022/12/02/9EWYarsVecQ7ij3.png)

从 blockchain.com 网站 截取一个最近的block:

![](https://s2.loli.net/2022/12/03/t1FDuAzh3HmIQLq.png)

可以看到，区块哈希与前一区块哈希都是以一长串0开头的，挖矿本身就是尝试各种nonce，使得产生的区块哈希值小于等于目标阈值。

看一下 block header 的代码描述: [bitcoin](https://github.com/bitcoin/bitcoin/blob/master/src/primitives/block.h)

![](https://s2.loli.net/2022/12/03/sC3A8qNUnXYLa9D.png)

nonce是一个32位的无符号整型数据，在挖矿时候是通过不断调整nonce进行的，但可以看到，nonce的取值最多为$2^{32}$种。但并非将这些nonce全部遍历一遍，就一定能找到符合要求的nonce。由于近年来，挖矿人员越来越多，挖矿难度已经调整的比较大了，而这一搜索空间太小，所以仅调整nonce很大可能找不到正确的结果。

可以看到除了nonce其他的元素只有ntime和hashMerkleRoot可以进行调整。我们主要是调整MerkleRoot。

每个发布区块者可以得到出快奖励，也就是可以在区块中发布一个 铸币交易(coinbase交易)
,这也是BTC系统中产生新比特币的唯一方式。中可以写入任何内容，在这里写什么都没有影响。所以可以在这里添加一些任意信息，便可以实现无法篡改（也无法删除）。所以，只要我们改变了写入内容，便可以改变Merkle Tree 的根哈希值。

所以，在实际的挖矿中，包含两层循环。外层循环调整coinbase域（可以规定只将其中前x个字节作为另一个nonce），算出block header中根哈希值后，内层循环再调整nonce。

### 概率分析

挖矿本质上是不断尝试各种nonce，来求解这样一个puzzle。每次尝试nonce，可以视为一次伯努利试验。最典型的
伯努利试验就是投掷硬币，正面和反面朝上概率为p和1-p。在挖矿过程中，一次伯努利试验，成功的概率极小，失败
的概率极大。挖矿便是多次进行伯努利试验，且每次随机。这些伯努利试验便构成了a sequence of independent
Bernoulli trials(一系列独立的伯努利试验)。根据概率论相关知识知道，伯努利试验本身具有无记忆性。也就是说，无论之前做多少大量试验，对后续继续试验没有任何影响。 对于挖矿来说，便是多次伯努利试验尝试nonce，最终找到一个符合要求的nonce。在这种情况下，可以采用泊松分布进行近似，由此通过概率论可以推断出，系统出块时间服从指数分布。(需要注意的是，出块时间指的是整个系统出块时间，并非挖矿的个人)

系统平均出块时间为10min，该时间为系统本身设计，通过难度调整维护其平均出块时间。 指数分布本身也具有无
记忆性。也就是说，对整个系统而言，已经过去10min，仍然没有人挖到区块，那么平均仍然还需要等10min（很不
符合人的直觉）。也就是说，将来要挖多久和已经挖多久无关。

### 工具演化

CPU->GPU->ASIC专用矿机

### 矿池

矿池通常是一个全节点驱动多台矿机。矿工只需要不停计算哈希值，而全节点其他职责由矿主来承担。ASIC芯片只能计算哈希值，不能实现全节点其他功能。此外，矿池出现解决了单个矿工收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。

矿池一般具有两种组织形式。1.类似大型数据中心（同一机构），集中成千上万矿机进行哈希计算。2.分布式。矿工
与矿主不认识(不同机构)，矿工与矿主联系，自愿加入其矿池，矿主分配任务，矿工进行计算，获得收益后整个矿池
中所有矿工进行利益分配。

### 难度调整

在比特币系统中，区块链的出块时间保持在平均10min左右。毫无疑问的是，伴随着参与挖矿的人增多，系统总算力不断增强，出块时间越来越短，虽然提高了系统效率但是增加了不稳定性，不利于达成共识，所以挖矿的难度绝对不能一成不变。

**这里的难度系数就是上面block信息中的difficulty**。

H(block header)<=target.（target便是目标阈值，target越小，目标难度就越大）对于挖矿难度的调
整，可以视为调整目标空间在整个输出空间中所占比例大小。

之前有提及，比特币系统采用的哈希算法为SHA-256，所以整个输出空间大小为$2^{256}$，调整目标空间所占比
例，简单的说需要目标值前需要多少个0。 当然，挖矿难度和目标阈值成反比，如下图所示，其中
difficulty-1-target为是挖矿难度为1时候的target，即最小挖矿难度:

$$difficulty = \frac{difficulty-1-target}{target} $$

在BTC协议中规定，每隔2016个区块需要调整一次难度，根据10min产生一个新区块可以得到，大概需要14天的时
间。具体调整公式如下：

$$\text { target }=\text { target } * \frac{\text { actual time }}{\text { expected time }}$$

> 可见，如果实际时间比较长，target会比较大，相应的挖矿难度会降低；如果实际时间比较短，target会比较小，相应的挖矿难度会增大。

如何让所有矿工都愿意调整这个挖矿难度呢？ 这一调整算法在代码中已经写入，如果有恶意节点故意不调，其
所产生的区块不会被大多数诚实的节点承认。 在block header中有一个nbits的域，它是对target的编码存储（target为256位，nbits为32位，也就是说block header并未直接存储target），其他节点在进行合法性验证时候会验证nbits域是否合法，不合法则对该区块不予以承认。

挖矿难度变低是好事吗？ 对于矿工来说，挖矿难度变低，挖矿变得更容易，这也说明大多数人对该币种
不再看好，这个币种的价值也会大跳水，这对矿工来说可是一个坏消息。

### 安全性分析

因为矿池的出现，引发了对51%算力攻击的担忧，矿工只负责计算，并不知道矿池的行为(**乌合之众**)。，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。

1. 分叉攻击: 
2. 封锁交易（Boycott） 假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。
3. 盗币（将他人账户BTC转走） 这个是不可能的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签
名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。
