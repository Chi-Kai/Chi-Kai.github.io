<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-CWBXLVG90W"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-CWBXLVG90W');
        }
      </script><meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="robots" content="index, follow"><meta name="author" content="KC">
<meta name="description" content="更新中">
<link rel="author" type="text/plain" href="/humans.txt">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#494f5c">
<meta name="msapplication-TileColor" content="#494f5c">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#494f5c">

  <meta itemprop="name" content="Redis源码剖析(一)">
  <meta itemprop="description" content="更新中">
  <meta itemprop="datePublished" content="2022-05-22T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-05-22T00:00:00+00:00">
  <meta itemprop="wordCount" content="11013">
  <meta itemprop="keywords" content="源码剖析,Redis"><meta property="og:url" content="http://localhost:1313/post/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/">
  <meta property="og:site_name" content="悉达多">
  <meta property="og:title" content="Redis源码剖析(一)">
  <meta property="og:description" content="更新中">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2022-05-22T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-05-22T00:00:00+00:00">
    <meta property="article:tag" content="源码剖析">
    <meta property="article:tag" content="Redis">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Redis源码剖析(一)">
  <meta name="twitter:description" content="更新中">

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Redis源码剖析(一)",
    "name": "Redis源码剖析(一)",
    "description": "更新中",
    "keywords": ["源码剖析", "Redis"],
    "articleBody": "基础数据结构部分 动态字符串 SDS 实现在 sds.h/sds.c。\n设计原则 为什么不使用c语言原生的字符串操作库? c字符串用'\\0'作为终止符，不能满足二进制安全，而且求字符串长度，拼接等操作都要遍历到'\\0'来实现，需要自己控制内存使用，操作复杂度高。\n前置知识 由于我对C语言没有深入了解，有很多知识点会在前面补充。\nattribute ((packed)): 对齐优化\nattribute((args)) 是GNU C的一个机制，可以通过编译器来修饰结构体，函数等。\n现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序地一个接一个地排放，这就是对齐.\n为了提高效率，计算机从内存中取数据是按照一个固定长度的。以32位机为例，它每次取32个位，也就是4个字节（每字节8个位)。字节对齐有什么好处？以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了\n使用__packed__参数是表示，使用原来的地址空间，编译时不要字节对齐，这样用时间换空间，使得结构体紧密。\n详细的用法见 机制详解。\nuint8_t uint16_t ... size_t 使用\n后面加_t表示是一个typedef 定义的类型，本质是原有类型。这样做是为了更好的跨平台移植，因为不同的平台中int,long 这些基础类型可能占用的字节不同，这对于一些对内存严格要求的库造成不便。使用uint8_t 等类型，在不同平台上都代表占一个字节8位，便于程序的实现。\n同理 size_t 也是用来保持跨平台移植性。可以是unsigned int unsigned char unsigned long等等，取决于实现，size_t = typeof(sizeof(X))。\nstatic inline\n头文件中很多函数使用了static inline 关键字，inline 建议编译器将函数作为一个宏内联，这样可以减少函数调用时的堆栈消耗，提高性能。但是编译器不一定会内联函数，这时候static可以保证这个函数是仅在本文件可见，避免重复包含冲突。\n数据结构 这里以sdshdr8为例\n// 一个字节 8位 // __attribute__ ((__packed__)) 用来告诉编译器取消结构在编译中的优化对齐，按照实际占用。 // 因为内存是按照2的倍数读取的，否则可能读两次,速度变慢。这里是用时间换空间 // 保证整个结构体的空间紧密 struct __attribute__ ((__packed__)) sdshdr8 { // buf 中已经使用的字节数 uint8_t len; /* used */ // 去掉头和null结束符，已经分配的字节数=有效长度+数据长度 uint8_t alloc; /* excluding the header and null terminator */ // 8位，只用前三位 unsigned char flags; /* 3 lsb of type, 5 unused bits */ // 柔性数组，没有分配之前不占内存 char buf[]; }; 记录了已经使用的空间和分配的空间，比C字符串操作效率更高。和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销，进一步就可以帮助诸多字符串操作更加高效地完成，比如创建、追加、复制、比较等。\n二进制安全 什么是二进制安全？通俗地讲，C语言中，用“\\0”表示字符串的结束，如果字符串中本身就有“\\0”字符，字符串就会被截断，即非二进制安全；若通过某种机制，保证读写字符串时不损害其内容，则是二进制安全。在网络报文中常常需要二进制安全。 sds使用 len 来控制字符串长度，而不是使用\"\\0\",保障了二进制安全。 极致的内存使用 对于不同的长度的字符串有不同的结构，上面的sdshdr8 表示长度为8位的字符串，还有sdshdr16/32/64。保证不会因为字符串过小而额外浪费字节，也不会因为字符串过长而频繁扩容。 - 结构体紧密，放弃对齐优化。在前置说明了结构体使用编译器参数packed来放弃优化，用时间换空间。 - flag。使用一个unsigned char,8位的小端三位来表示结构体的性质(5/8/16/32/64)。 - 变长数组（柔性数组）。柔性数组成员（flexible array member），也叫伸缩性数组成员，只能被放在结构体的末尾。包含柔性数组成员的结构体，通过malloc函数为柔性数组动态分配内存。之所以用柔性数组存放字符串，是因为柔性数组的地址和结构体是连续的，这样查找内存更快（因为不需要额外通过指针找到字符串的位置）；可以很方便地通过柔性数组的首地址偏移得到结构体首地址，进而能很方便地获取其余变量。 与c字符串函数 始终将buf指针暴露给上层，可以和c字符串函数切合。同时可以很容易地通过减去一个sdshdr大小偏移到结构体首部来调用结构体属性。 如下面的宏定义: ```c #define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); #define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) ``` 基本操作 创建 sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) { void *sh; sds s; char type = sdsReqType(initlen); // 因为通常总是有空字符串，而使用type5每增加一次就需要扩容，所以直接使用type 8 ---- 为什么不把type5直接删了？ /* Empty strings are usually created in order to append. Use type 8 * since type 5 is not good at this. */ if (type == SDS_TYPE_5 \u0026\u0026 initlen == 0) type = SDS_TYPE_8; int hdrlen = sdsHdrSize(type); unsigned char *fp; /* flags pointer. */ size_t usable; // initlen 是buf中实际装的大小，hdrlen是sds header大小，+1 是\\0终止符 assert(initlen + hdrlen + 1 \u003e initlen); /* Catch size_t overflow */ //malloc_usable还是调用tyymalloc_usable sh = trymalloc? s_trymalloc_usable(hdrlen+initlen+1, \u0026usable) : s_malloc_usable(hdrlen+initlen+1, \u0026usable); if (sh == NULL) return NULL; if (init==SDS_NOINIT) init = NULL; else if (!init) memset(sh, 0, hdrlen+initlen+1); // 指向buf s = (char*)sh+hdrlen; fp = ((unsigned char*)s)-1; usable = usable-hdrlen-1; // 可能申请的超过类型MaxSize if (usable \u003e sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); switch(type) { case SDS_TYPE_5: { *fp = type | (initlen \u003c\u003c SDS_TYPE_BITS); break; } case SDS_TYPE_8: { SDS_HDR_VAR(8,s); sh-\u003elen = initlen; sh-\u003ealloc = usable; *fp = type; break; } // ... } if (initlen \u0026\u0026 init) memcpy(s, init, initlen); s[initlen] = '\\0'; return s; } 首先根据申请的初始大小来确定类型，通过类型可以确定hdr大小，然后来申请空间。 这里使用的s_trymalloc_usable与s_malloc_usable都是文件zmallo.c实现的内存管理函数，后面会专门讲解。这里只用知道它会申请前一个参数大小的空间，并且将空间大小赋值给后一个参数usable。 得到空间的首地址，加上头大小得到buf地址s,s[-1] 得到类型指针fp,usable减去头大小hdrlen和类型大小1得到实际可用大小。 根据类型来构建一个sds结构体，最后返回是buf的指针，补上终止符'\\0'。这里使用的是一个宏，可以借鉴这种写法，一个经常使用的操作，如果写成函数，会增加堆栈调度消耗，写成宏可以提高性能，代价是编译后的文件大小会增加。 这是sds创建的底层实现，实际使用的是上层的封装，只是对这个函数的封装调用。\n销毁 有两种方法，一种是直接销毁:\nvoid sdsfree(sds s) { if (s == NULL) return; s_free((char*)s-sdsHdrSize(s[-1])); } 一种是仅仅将sds的len标记为0,但是实际的buf并不会释放，而是等待覆写。这样可以优化性能。\n扩容 sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) { void *sh, *newsh; size_t avail = sdsavail(s); size_t len, newlen, reqlen; char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; int hdrlen; size_t usable; /* Return ASAP if there is enough space left. */ if (avail \u003e= addlen) return s; len = sdslen(s); sh = (char*)s-sdsHdrSize(oldtype); reqlen = newlen = (len+addlen); // 这里是防止溢出 assert(newlen \u003e len); /* Catch size_t overflow */ if (greedy == 1) { // SDS_MAX_PREALLOC 是 1MB if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; } type = sdsReqType(newlen); /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) type = SDS_TYPE_8; hdrlen = sdsHdrSize(type); assert(hdrlen + newlen + 1 \u003e reqlen); /* Catch size_t overflow */ if (oldtype==type) { // 和原类型相同，则不用释放内存，直接将buf扩容即可 newsh = s_realloc_usable(sh, hdrlen+newlen+1, \u0026usable); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { /* Since the header size changes, need to move the string forward, * and can't use realloc */ // 类型改变,需要重新申请内存，原内存释放 newsh = s_malloc_usable(hdrlen+newlen+1, \u0026usable); if (newsh == NULL) return NULL; memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } usable = usable-hdrlen-1; // type 是通过newlen判断得到的，而usable 是 hdrlen + newlen + 1 可能出现超出的情况 if (usable \u003e sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); sdssetalloc(s, usable); return s; } 首先判断newlen加上len是否超出可用的大小avail,没超就不扩容。 和之前不同，这一版本加入了greedy参数，来调节扩容策略，当greedy为1时，每次会扩大的比所需要的更多，这样可以减少扩容频率。而greedy为0时，就是节约内存 greedy为1时启用此策略: 如果newlen小于1MB,每次扩容二背，大于1MB时每次增加1MB。（每次2倍内存很快就耗尽了） 这里根据新的newlen来确定类型，如果类型不变，只需要扩展buf数组，而类型改变的话就需要重新申请内存。 跳表zskiplist 对应的代码在 server.h 和 t_zset.c。\n跳表可以看作链表加上都多层索引，一般每两个\n/* ZSETs use a specialized version of Skiplists */ typedef struct zskiplistNode { sds ele; // 存储字符串类型的数据 double score; // 储存排序的分值 struct zskiplistNode *backward; // 后向指针 头节点和第一个节点都为NULL struct zskiplistLevel { struct zskiplistNode *forward; // 指向本层下一个节点 unsigned long span; // 跨度 指向本层下一个节点中间跨越的节点个数 } level[]; // 柔性数组，未分配内存时不占空间。初始化时，level 随机分配1~32 } zskiplistNode; typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; // 除了头节点以外节点总数 int level; // 跳表的高度 } zskiplist; 用的图片是网图 链接，其中obj一般为sds，在Redis6中已经改为sds ele。\n可以从图和代码很清晰地看出跳跃表的结构。\n跳跃表是Redis有序集合的底层实现方式之一，所以每个节点的ele存储有序集合的成员member值，score存储成员score值。所有节点的分值是按从小到大的方式排序的，当有序集合的成员分值相同时，节点会按member的字典序进行排序。\n通过跳跃表结构体的属性我们可以看到，程序可以在O(1)的时间复杂度下，快速获取到跳跃表的头节点、尾节点、长度和高度。\n创建 Redis通过zslRandomLevel函数随机生成一个1～32的值，作为新建节点的高度，值越大出现的概率越低。节点层高确定之后便不会再修改。生成随机层高的代码如下。\n// ZSKIPLIST 为 0.25 int zslRandomLevel(void) { static const int threshold = ZSKIPLIST_P*RAND_MAX; int level = 1; while (random() \u003c threshold) level += 1; // 这里 ZSKIPLIST_MAXLEVEL 为32 return (level\u003cZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; } 当p=0.25时，跳跃表节点的期望层高为1/(1-0.25)≈1.33。\n下面是创建函数\n/* Create a skiplist node with the specified number of levels. * The SDS string 'ele' is referenced by the node after the call. */ zskiplistNode *zslCreateNode(int level, double score, sds ele) { zskiplistNode *zn = // level 柔性数组加上头大小 来申请内存 zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel)); zn-\u003escore = score; zn-\u003eele = ele; return zn; } /* Create a new skiplist. */ zskiplist *zslCreate(void) { int j; zskiplist *zsl; zsl = zmalloc(sizeof(*zsl)); zsl-\u003elevel = 1; zsl-\u003elength = 0; // 头节点的level是最大层数 zsl-\u003eheader = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); for (j = 0; j \u003c ZSKIPLIST_MAXLEVEL; j++) { zsl-\u003eheader-\u003elevel[j].forward = NULL; zsl-\u003eheader-\u003elevel[j].span = 0; } zsl-\u003eheader-\u003ebackward = NULL; zsl-\u003etail = NULL; return zsl; } 头节点是一个特殊的节点，不存储有序集合的member信息。头节点是跳跃表中第一个插入的节点，其level数组的每项forward都为NULL, span值都为0\n插入 /* Insert a new node in the skiplist. Assumes the element does not already * exist (up to the caller to enforce that). The skiplist takes ownership * of the passed SDS string 'ele'. */ zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) { // 记录每层所能到达的最右边节点 zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; // 记录每层从header到update[i}所需的步长 unsigned long rank[ZSKIPLIST_MAXLEVEL]; int i, level; // 判断score 是不是NAN serverAssert(!isnan(score)); x = zsl-\u003eheader; // 从最高层索引开始遍历 for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { /* store rank that is crossed to reach the insert position */ // 当在最高层时，先将rank赋值为0，先假设 rank[i] = i == (zsl-\u003elevel-1) ? 0 : rank[i+1]; // 在第i层一直向前移动比较,因为是按照score 从小到大排列的 // 找到这层大于插入score 的位置然后下移 while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c 0))) { // 更新总的span rank[i] += x-\u003elevel[i].span; x = x-\u003elevel[i].forward; } // 记录这层的终点 update[i] = x; } /* we assume the element is not already inside, since we allow duplicated * scores, reinserting the same element should never happen since the * caller of zslInsert() should test in the hash table if the element is * already inside or not. */ // zslInsert不能应用在插入节点已经存在的情况下。 // 所以不用检查存在 //为插入节点计算随机层数 level = zslRandomLevel(); //大于原来层高的部分，只需要调整header就行。 if (level \u003e zsl-\u003elevel) { for (i = zsl-\u003elevel; i \u003c level; i++) { rank[i] = 0; update[i] = zsl-\u003eheader; // 为啥是这个？可能是用来占位 update[i]-\u003elevel[i].span = zsl-\u003elength; } zsl-\u003elevel = level; } x = zslCreateNode(level,score,ele); for (i = 0; i \u003c level; i++) { // 插入到每层最右侧能到达的节点之后 x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward; update[i]-\u003elevel[i].forward = x; /* update span covered by update[i] as x is inserted here */ // 插入节点每层的span更新,这个看下图 x-\u003elevel[i].span = update[i]-\u003elevel[i].span - (rank[0] - rank[i]); update[i]-\u003elevel[i].span = (rank[0] - rank[i]) + 1; } /* increment span for untouched levels */ for (i = level; i \u003c zsl-\u003elevel; i++) { update[i]-\u003elevel[i].span++; } x-\u003ebackward = (update[0] == zsl-\u003eheader) ? NULL : update[0]; if (x-\u003elevel[0].forward) x-\u003elevel[0].forward-\u003ebackward = x; else zsl-\u003etail = x; zsl-\u003elength++; return x; } 下图来源于 链接\n以节点19插入为例，其中 黑色箭头的表示的跨度为update[i]-\u003elevel[i].span 蓝色箭头表示的跨度为rank[0] - rank[i]即节点19在level_0的update[0]为11， 在level_1的update[1]为7，rank[0] - rank[i]为节点7与节点11之间的跨度 绿色箭头表示的跨度为节点19到节点37的span\n删除 首先查找到对应的节点，将每层最右边到达的节点记录下来，对应的update。 辅助函数:\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) { // 调整对应的span和forward int i; for (i = 0; i \u003c zsl-\u003elevel; i++) { if (update[i]-\u003elevel[i].forward == x) { update[i]-\u003elevel[i].span += x-\u003elevel[i].span - 1; update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward; } else { update[i]-\u003elevel[i].span -= 1; } } if (x-\u003elevel[0].forward) { x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward; } else { zsl-\u003etail = x-\u003ebackward; } // 调整level while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == NULL) zsl-\u003elevel--; zsl-\u003elength--; } 删除函数:\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) { zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; int i; //查找位置 x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c 0))) { x = x-\u003elevel[i].forward; } // 保存每层最右边的节点 update[i] = x; } /* We may have multiple elements with the same score, what we need * is to find the element with both the right score and object. */ // 可能同一个score有多个ele x = x-\u003elevel[0].forward; if (x \u0026\u0026 score == x-\u003escore \u0026\u0026 sdscmp(x-\u003eele,ele) == 0) { zslDeleteNode(zsl, x, update); if (!node) zslFreeNode(x); else *node = x; return 1; } return 0; /* not found */ } 压缩列表 具体的实现在ziplist.h和ziplist.c\n压缩列表是Redis中一种高效利用内存的数据结构，用来储存字符串和数字，它的push和pop操作都是 O(1) 。Redis的有序集合、散列和列表都直接或者间接使用了压缩列表。当有序集合或散列表的元素个数比较少，且元素都是短字符串时，Redis便使用压缩列表作为其底层数据存储结构。列表使用快速链表（quicklist）数据结构存储，而快速链表就是双向链表与压缩列表的组合。\n// ziplist 结构 \u003czlbytes\u003e \u003czltail\u003e \u003czllen\u003e \u003centry\u003e \u003centry\u003e ... \u003centry\u003e \u003czlend\u003e 这里的所有结构都是按照小端存储。\nzlbytes: 压缩列表的字节长度，占4个字节，因此压缩列表最多有$2^{32}-1$个字节。这个设计是为了resize时不必遍历整个列表 zltail: 压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节，这个设计可以使pop操作不必要遍历全部。 zllen: 压缩列表的元素个数，占2个字节。zllen无法存储元素个数超过65535（$2^{16}-1$）的压缩列表，必须遍历整个压缩列表才能获取到元素个数。 zlend: 压缩列表的结尾，占1个字节，恒为0xFF。 这里可以清楚地感受到C语言对内存的掌控，通过指针位移来获取结构信息。这里使用宏又是C语言的一个特色，比起inline只是建议编译器内联，宏真正是内联，对于一些细小而频繁的操作提高了性能。\n/* Return total bytes a ziplist is composed of. */ #define ZIPLIST_BYTES(zl) (*((uint32_t*)(zl))) /* Return the offset of the last item inside the ziplist. */ #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t)))) /* Return the length of a ziplist, or UINT16_MAX if the length cannot be * determined without scanning the whole ziplist. */ #define ZIPLIST_LENGTH(zl) (*((uint16_t*)((zl)+sizeof(uint32_t)*2))) /* The size of a ziplist header: two 32 bit integers for the total * bytes count and last item offset. One 16 bit integer for the number * of items field. */ #define ZIPLIST_HEADER_SIZE (sizeof(uint32_t)*2+sizeof(uint16_t)) /* Size of the \"end of ziplist\" entry. Just one byte. */ #define ZIPLIST_END_SIZE (sizeof(uint8_t)) /* Return the pointer to the first entry of a ziplist. */ #define ZIPLIST_ENTRY_HEAD(zl) ((zl)+ZIPLIST_HEADER_SIZE) /* Return the pointer to the last entry of a ziplist, using the * last entry offset inside the ziplist header. */ #define ZIPLIST_ENTRY_TAIL(zl) ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) /* Return the pointer to the last byte of a ziplist, which is, the * end of ziplist FF entry. */ #define ZIPLIST_ENTRY_END(zl) ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-ZIPLIST_END_SIZE) 对于 结构如下:\n\u003cprevlen\u003e \u003cencoding\u003e \u003centry-data\u003e previous_entry_length字段表示前一个元素的字节长度，占1个或者5个字节，当前一个元素的长度小于254字节时，用1个字节表示；当前一个元素的长度大于或等于254字节时，用5个字节来表示。而此时previous_entry_length字段的第1个字节是固定的0xFE，后面4个字节才真正表示前一个元素的长度。假设已知当前元素的首地址为p，那么p-previous_entry_length就是前一个元素的首地址，从而实现压缩列表从尾到头的遍历。\nencoding字段表示当前元素的编码，即content字段存储的数据类型（整数或者字节数组），数据内容存储在content字段。为了节约内存，encoding字段同样长度可变。\nRedis使用宏来表示\n#define ZIP_STR_MASK 0xc0 #define ZIP_INT_MASK 0x30 #define ZIP_STR_06B (0 \u003c\u003c 6) #define ZIP_STR_14B (1 \u003c\u003c 6) #define ZIP_STR_32B (2 \u003c\u003c 6) #define ZIP_INT_16B (0xc0 | 0\u003c\u003c4) #define ZIP_INT_32B (0xc0 | 1\u003c\u003c4) #define ZIP_INT_64B (0xc0 | 2\u003c\u003c4) #define ZIP_INT_24B (0xc0 | 3\u003c\u003c4) #define ZIP_INT_8B 0xfe 这里使用位运算来代表类型，既节省了内存又提高了性能。\n结构 typedef struct zlentry { unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/ unsigned int prevrawlen; /* Previous entry len. */ unsigned int lensize; /* Bytes used to encode this entry type/len. For example strings have a 1, 2 or 5 bytes header. Integers always use a single byte.*/ unsigned int len; /* Bytes used to represent the actual entry. For strings this is just the string length while for integers it is 1, 2, 3, 4, 8 or 0 (for 4 bit immediate) depending on the number range. */ unsigned int headersize; /* prevrawlensize + lensize. */ unsigned char encoding; /* Set to ZIP_STR_* or ZIP_INT_* depending on the entry encoding. However for 4 bits immediate integers this can assume a range of values and must be range-checked. */ unsigned char *p; /* Pointer to the very start of the entry, that is, this points to prev-entry-len field. */ } zlentry; 对于压缩列表的任意元素，获取前一个元素的长度、判断存储的数据类型、获取数据内容都需要经过复杂的解码运算。解码后的结果应该被缓存起来，为此定义了结构体zlentry，用于表示解码后的压缩列表元素。\n解码操作，主要用宏实现:\nstatic inline void zipEntry(unsigned char *p, zlentry *e) { ZIP_DECODE_PREVLEN(p, e-\u003eprevrawlensize, e-\u003eprevrawlen); ZIP_ENTRY_ENCODING(p + e-\u003eprevrawlensize, e-\u003eencoding); ZIP_DECODE_LENGTH(p + e-\u003eprevrawlensize, e-\u003eencoding, e-\u003elensize, e-\u003elen); assert(e-\u003elensize != 0); /* check that encoding was valid. */ e-\u003eheadersize = e-\u003eprevrawlensize + e-\u003elensize; e-\u003ep = p; } 这里主要就是对字节的读取，可以去看源代码。\n操作 创建 /* Create a new empty ziplist. */ // 先申请初始的空间(4+4+2+1),再对zlbytes,zltail,zllen,zlend逐个初始化 unsigned char *ziplistNew(void) { unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE; unsigned char *zl = zmalloc(bytes); ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE); ZIPLIST_LENGTH(zl) = 0; zl[bytes-1] = ZIP_END; return zl; } 插入元素 编码。计算previous_entry_length字段、encoding字段和content字段的内容。 字典 结构 节点:\ntypedef struct dictEntry { void *key; // 节省内存 不同场景下使用不同字段 union { void *val; // db.dict 储存值 uint64_t u64; int64_t s64; // db.expires 储存过期时间 double d; } v; // 单链表法 解决哈希冲突。 struct dictEntry *next; /* Next entry in the same hash bucket. */ void *metadata[]; /* An arbitrary number of bytes (starting at a * pointer-aligned address) of size as returned * by dictType's dictEntryMetadataBytes(). */ } dictEntry; 可以看出是使用链表法来解决hash冲突的。\nstruct dict { dictType *type; // 对应特定类型操作函数 dictEntry **ht_table[2]; // 哈希表。有两个，一个正常使用，另外一个在rehash时使用 unsigned long ht_used[2]; // 记录每个哈希表被使用的数目。 long rehashidx; /* rehashing not in progress if rehashidx == -1 */ /* Keep small vars at end for optimal (minimal) struct padding */ int16_t pauserehash; /* If \u003e0 rehashing is paused (\u003c0 indicates coding error) */ // size 的 系数，size 是2 的N次幂 signed char ht_size_exp[2]; /* exponent of size. (size = 1\u003c",
    "wordCount" : "11013",
    "inLanguage": "cn",
    "datePublished": "2022-05-22T00:00:00Z",
    "dateModified": "2022-05-22T00:00:00Z",
    "author":{
        "@type": "Person",
        "name": "KC",},
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http://localhost:1313/post/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "悉达多",
      "description": "成功只有一个:按照自己的方式，去度过人生\n",
      "logo": {
        "@type": "ImageObject",
        "url": "http://localhost:1313/favicon.ico"
      }
    }
}
</script><title>Redis源码剖析(一)</title>
<link rel="stylesheet dns-prefetch preconnect preload prefetch" as="style" media="screen" href="http://localhost:1313/css/style.min.65788784967ef394e528967eed8c63658368c6c4d417053ce77fd6c5ba25d364.css" integrity="sha256-ZXiHhJZ+85TlKJZ+7YxjZYNoxsTUFwU853/Wxbol02Q=" crossorigin="anonymous">
	</head>
<body id="page">
	<header id="site-header">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://localhost:1313/">悉达多</a>
				</div>
				<nav class="site-nav hide-in-mobile"><a href="http://localhost:1313/post/">Posts</a><a href="http://localhost:1313/tags/">Tags</a><a href="http://localhost:1313/about/">About</a></nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list">
      <line x1="8" y1="6" x2="21" y2="6"></line>
      <line x1="8" y1="12" x2="21" y2="12"></line>
      <line x1="8" y1="18" x2="21" y2="18"></line>
      <line x1="3" y1="6" x2="3" y2="6"></line>
      <line x1="3" y1="12" x2="3" y2="12"></line>
      <line x1="3" y1="18" x2="3" y2="18"></line>
   </svg></button><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
   </svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://localhost:1313/post/">Posts</a></li>
			<li><a href="http://localhost:1313/tags/">Tags</a></li>
			<li><a href="http://localhost:1313/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>Redis源码剖析(一)</h1>
		<div class="content">
			<h1 id="基础数据结构部分">基础数据结构部分<a href="#%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e9%83%a8%e5%88%86" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<h2 id="动态字符串-sds">动态字符串 SDS<a href="#%e5%8a%a8%e6%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2-sds" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>实现在 sds.h/sds.c。</p>
<h3 id="设计原则">设计原则<a href="#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>为什么不使用c语言原生的字符串操作库? c字符串用'\0'作为终止符，不能满足二进制安全，而且求字符串长度，拼接等操作都要遍历到'\0'来实现，需要自己控制内存使用，操作复杂度高。</p>
<h3 id="前置知识">前置知识<a href="#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>由于我对C语言没有深入了解，有很多知识点会在前面补充。</p>
<ul>
<li>
<p><strong>attribute</strong> ((<strong>packed</strong>)): 对齐优化</p>
<p><strong>attribute</strong>((args)) 是GNU C的一个机制，可以通过编译器来修饰结构体，函数等。</p>
<p>现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序地一个接一个地排放，这就是对齐.</p>
<p>为了提高效率，计算机从内存中取数据是按照一个固定长度的。以32位机为例，它每次取32个位，也就是4个字节（每字节8个位)。字节对齐有什么好处？以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了</p>
<p>使用__packed__参数是表示，使用原来的地址空间，编译时不要字节对齐，这样用时间换空间，使得结构体紧密。</p>
<p>详细的用法见 <a href="https://blog.csdn.net/weaiken/article/details/88085360">机制详解</a>。</p>
</li>
<li>
<p>uint8_t uint16_t ... size_t 使用</p>
<p>后面加_t表示是一个typedef 定义的类型，本质是原有类型。这样做是为了更好的跨平台移植，因为不同的平台中int,long 这些基础类型可能占用的字节不同，这对于一些对内存严格要求的库造成不便。使用uint8_t 等类型，在不同平台上都代表占一个字节8位，便于程序的实现。</p>
<p>同理 size_t 也是用来保持跨平台移植性。可以是unsigned int unsigned char unsigned long等等，取决于实现，size_t = typeof(sizeof(X))。</p>
</li>
<li>
<p>static inline</p>
<p>头文件中很多函数使用了static inline 关键字，inline 建议编译器将函数作为一个宏内联，这样可以减少函数调用时的堆栈消耗，提高性能。但是编译器不一定会内联函数，这时候static可以保证这个函数是仅在本文件可见，避免重复包含冲突。</p>
</li>
</ul>
<h3 id="数据结构">数据结构<a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>这里以sdshdr8为例</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 一个字节 8位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __attribute__ ((__packed__)) 用来告诉编译器取消结构在编译中的优化对齐，按照实际占用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为内存是按照2的倍数读取的，否则可能读两次,速度变慢。这里是用时间换空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 保证整个结构体的空间紧密
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#00a8c8">struct</span> <span style="color:#75af00">__attribute__</span> <span style="color:#111">((</span><span style="color:#111">__packed__</span><span style="color:#111">))</span> <span style="color:#111">sdshdr8</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// buf 中已经使用的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">uint8_t</span> <span style="color:#111">len</span><span style="color:#111">;</span> <span style="color:#75715e">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 去掉头和null结束符，已经分配的字节数=有效长度+数据长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">uint8_t</span> <span style="color:#111">alloc</span><span style="color:#111">;</span> <span style="color:#75715e">/* excluding the header and null terminator */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 8位，只用前三位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#111">flags</span><span style="color:#111">;</span> <span style="color:#75715e">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 柔性数组，没有分配之前不占内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">char</span> <span style="color:#111">buf</span><span style="color:#111">[];</span>
</span></span><span style="display:flex;"><span><span style="color:#111">};</span>
</span></span></code></pre></div><p>记录了已经使用的空间和分配的空间，比C字符串操作效率更高。和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销，进一步就可以帮助诸多字符串操作更加高效地完成，比如创建、追加、复制、比较等。</p>
<h4 id="二进制安全">二进制安全<a href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ae%89%e5%85%a8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<pre><code>什么是二进制安全？通俗地讲，C语言中，用“\0”表示字符串的结束，如果字符串中本身就有“\0”字符，字符串就会被截断，即非二进制安全；若通过某种机制，保证读写字符串时不损害其内容，则是二进制安全。在网络报文中常常需要二进制安全。

sds使用 len 来控制字符串长度，而不是使用&quot;\0&quot;,保障了二进制安全。 
</code></pre>
<h4 id="极致的内存使用">极致的内存使用<a href="#%e6%9e%81%e8%87%b4%e7%9a%84%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<ul>
<li>对于不同的长度的字符串有不同的结构，上面的sdshdr8 表示长度为8位的字符串，还有sdshdr16/32/64。保证不会因为字符串过小而额外浪费字节，也不会因为字符串过长而频繁扩容。
- 结构体紧密，放弃对齐优化。在前置说明了结构体使用编译器参数packed来放弃优化，<strong>用时间换空间</strong>。
- flag。使用一个unsigned char,8位的小端三位来表示结构体的性质(5/8/16/32/64)。
- 变长数组（柔性数组）。柔性数组成员（flexible array member），也叫伸缩性数组成员，<strong>只能被放在结构体的末尾</strong>。包含柔性数组成员的结构体，通过malloc函数为柔性数组动态分配内存。之所以用柔性数组存放字符串，是因为柔性数组的地址和结构体是连续的，这样查找内存更快（因为不需要额外通过指针找到字符串的位置）；可以很方便地通过柔性数组的首地址偏移得到结构体首地址，进而能很方便地获取其余变量。</li>
</ul>
<h4 id="与c字符串函数">与c字符串函数<a href="#%e4%b8%8ec%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%87%bd%e6%95%b0" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<pre><code>始终将buf指针暴露给上层，可以和c字符串函数切合。同时可以很容易地通过减去一个sdshdr大小偏移到结构体首部来调用结构体属性。
	
如下面的宏定义:

```c
#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
```
</code></pre>
<h3 id="基本操作">基本操作<a href="#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<h4 id="创建">创建<a href="#%e5%88%9b%e5%bb%ba" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#111">sds</span> <span style="color:#75af00">_sdsnewlen</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">init</span><span style="color:#111">,</span> <span style="color:#00a8c8">size_t</span> <span style="color:#111">initlen</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">trymalloc</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">sh</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">sds</span> <span style="color:#111">s</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">char</span> <span style="color:#111">type</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsReqType</span><span style="color:#111">(</span><span style="color:#111">initlen</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 因为通常总是有空字符串，而使用type5每增加一次就需要扩容，所以直接使用type 8 ---- 为什么不把type5直接删了？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/* Empty strings are usually created in order to append. Use type 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * since type 5 is not good at this. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">type</span> <span style="color:#f92672">==</span> <span style="color:#111">SDS_TYPE_5</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#111">initlen</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#111">type</span> <span style="color:#f92672">=</span> <span style="color:#111">SDS_TYPE_8</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">hdrlen</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsHdrSize</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#f92672">*</span><span style="color:#111">fp</span><span style="color:#111">;</span> <span style="color:#75715e">/* flags pointer. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">size_t</span> <span style="color:#111">usable</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// initlen 是buf中实际装的大小，hdrlen是sds header大小，+1 是\0终止符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75af00">assert</span><span style="color:#111">(</span><span style="color:#111">initlen</span> <span style="color:#f92672">+</span> <span style="color:#111">hdrlen</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> <span style="color:#111">initlen</span><span style="color:#111">);</span> <span style="color:#75715e">/* Catch size_t overflow */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//malloc_usable还是调用tyymalloc_usable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">sh</span> <span style="color:#f92672">=</span> <span style="color:#111">trymalloc</span><span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">s_trymalloc_usable</span><span style="color:#111">(</span><span style="color:#111">hdrlen</span><span style="color:#f92672">+</span><span style="color:#111">initlen</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#f92672">&amp;</span><span style="color:#111">usable</span><span style="color:#111">)</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">s_malloc_usable</span><span style="color:#111">(</span><span style="color:#111">hdrlen</span><span style="color:#f92672">+</span><span style="color:#111">initlen</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#f92672">&amp;</span><span style="color:#111">usable</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">sh</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">init</span><span style="color:#f92672">==</span><span style="color:#111">SDS_NOINIT</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">init</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">else</span> <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#111">init</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">memset</span><span style="color:#111">(</span><span style="color:#111">sh</span><span style="color:#111">,</span> <span style="color:#ae81ff">0</span><span style="color:#111">,</span> <span style="color:#111">hdrlen</span><span style="color:#f92672">+</span><span style="color:#111">initlen</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 指向buf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">s</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">sh</span><span style="color:#f92672">+</span><span style="color:#111">hdrlen</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">fp</span> <span style="color:#f92672">=</span> <span style="color:#111">((</span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">s</span><span style="color:#111">)</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">usable</span> <span style="color:#f92672">=</span> <span style="color:#111">usable</span><span style="color:#f92672">-</span><span style="color:#111">hdrlen</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可能申请的超过类型MaxSize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">usable</span> <span style="color:#f92672">&gt;</span> <span style="color:#75af00">sdsTypeMaxSize</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">usable</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsTypeMaxSize</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">switch</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">case</span> <span style="color:#111">SDS_TYPE_5</span><span style="color:#111">:</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span><span style="color:#111">fp</span> <span style="color:#f92672">=</span> <span style="color:#111">type</span> <span style="color:#f92672">|</span> <span style="color:#111">(</span><span style="color:#111">initlen</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#111">SDS_TYPE_BITS</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">break</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">case</span> <span style="color:#111">SDS_TYPE_8</span><span style="color:#111">:</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75af00">SDS_HDR_VAR</span><span style="color:#111">(</span><span style="color:#ae81ff">8</span><span style="color:#111">,</span><span style="color:#111">s</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">sh</span><span style="color:#f92672">-&gt;</span><span style="color:#111">len</span> <span style="color:#f92672">=</span> <span style="color:#111">initlen</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">sh</span><span style="color:#f92672">-&gt;</span><span style="color:#111">alloc</span> <span style="color:#f92672">=</span> <span style="color:#111">usable</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span><span style="color:#111">fp</span> <span style="color:#f92672">=</span> <span style="color:#111">type</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">break</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">initlen</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#111">init</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">memcpy</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">,</span> <span style="color:#111">init</span><span style="color:#111">,</span> <span style="color:#111">initlen</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#111">initlen</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#d88200">&#39;\0&#39;</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">s</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><ol>
<li>首先根据申请的初始大小来确定类型，通过类型可以确定hdr大小，然后来申请空间。</li>
<li>这里使用的s_trymalloc_usable与s_malloc_usable都是文件zmallo.c实现的内存管理函数，后面会专门讲解。这里只用知道它会申请前一个参数大小的空间，并且将空间大小赋值给后一个参数usable。</li>
<li>得到空间的首地址，加上头大小得到buf地址s,s[-1] 得到类型指针fp,usable减去头大小hdrlen和类型大小1得到实际可用大小。</li>
<li>根据类型来构建一个sds结构体，最后返回是buf的指针，补上终止符'\0'。这里使用的是一个宏，可以借鉴这种写法，一个经常使用的操作，如果写成函数，会增加堆栈调度消耗，写成宏可以提高性能，代价是编译后的文件大小会增加。</li>
</ol>
<p>这是sds创建的底层实现，实际使用的是上层的封装，只是对这个函数的封装调用。</p>
<h4 id="销毁">销毁<a href="#%e9%94%80%e6%af%81" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<p>有两种方法，一种是直接销毁:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">void</span> <span style="color:#75af00">sdsfree</span><span style="color:#111">(</span><span style="color:#111">sds</span> <span style="color:#111">s</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">s</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">s_free</span><span style="color:#111">((</span><span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">s</span><span style="color:#f92672">-</span><span style="color:#75af00">sdsHdrSize</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">]));</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>一种是仅仅将sds的len标记为0,但是实际的buf并不会释放，而是等待覆写。这样可以优化性能。</p>
<h4 id="扩容">扩容<a href="#%e6%89%a9%e5%ae%b9" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#111">sds</span> <span style="color:#75af00">_sdsMakeRoomFor</span><span style="color:#111">(</span><span style="color:#111">sds</span> <span style="color:#111">s</span><span style="color:#111">,</span> <span style="color:#00a8c8">size_t</span> <span style="color:#111">addlen</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">greedy</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">sh</span><span style="color:#111">,</span> <span style="color:#f92672">*</span><span style="color:#111">newsh</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">size_t</span> <span style="color:#111">avail</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsavail</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">size_t</span> <span style="color:#111">len</span><span style="color:#111">,</span> <span style="color:#111">newlen</span><span style="color:#111">,</span> <span style="color:#111">reqlen</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">char</span> <span style="color:#111">type</span><span style="color:#111">,</span> <span style="color:#111">oldtype</span> <span style="color:#f92672">=</span> <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">&amp;</span> <span style="color:#111">SDS_TYPE_MASK</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">hdrlen</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">size_t</span> <span style="color:#111">usable</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Return ASAP if there is enough space left. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">avail</span> <span style="color:#f92672">&gt;=</span> <span style="color:#111">addlen</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">s</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">len</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdslen</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">sh</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">s</span><span style="color:#f92672">-</span><span style="color:#75af00">sdsHdrSize</span><span style="color:#111">(</span><span style="color:#111">oldtype</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">reqlen</span> <span style="color:#f92672">=</span> <span style="color:#111">newlen</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#111">len</span><span style="color:#f92672">+</span><span style="color:#111">addlen</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里是防止溢出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75af00">assert</span><span style="color:#111">(</span><span style="color:#111">newlen</span> <span style="color:#f92672">&gt;</span> <span style="color:#111">len</span><span style="color:#111">);</span>   <span style="color:#75715e">/* Catch size_t overflow */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">greedy</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// SDS_MAX_PREALLOC 是 1MB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">newlen</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">SDS_MAX_PREALLOC</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">newlen</span> <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">newlen</span> <span style="color:#f92672">+=</span> <span style="color:#111">SDS_MAX_PREALLOC</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">type</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsReqType</span><span style="color:#111">(</span><span style="color:#111">newlen</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Don&#39;t use type 5: the user is appending to the string and type 5 is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * not able to remember empty space, so sdsMakeRoomFor() must be called
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * at every appending operation. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">type</span> <span style="color:#f92672">==</span> <span style="color:#111">SDS_TYPE_5</span><span style="color:#111">)</span> <span style="color:#111">type</span> <span style="color:#f92672">=</span> <span style="color:#111">SDS_TYPE_8</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">hdrlen</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsHdrSize</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">assert</span><span style="color:#111">(</span><span style="color:#111">hdrlen</span> <span style="color:#f92672">+</span> <span style="color:#111">newlen</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> <span style="color:#111">reqlen</span><span style="color:#111">);</span>  <span style="color:#75715e">/* Catch size_t overflow */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">oldtype</span><span style="color:#f92672">==</span><span style="color:#111">type</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 和原类型相同，则不用释放内存，直接将buf扩容即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">newsh</span> <span style="color:#f92672">=</span> <span style="color:#75af00">s_realloc_usable</span><span style="color:#111">(</span><span style="color:#111">sh</span><span style="color:#111">,</span> <span style="color:#111">hdrlen</span><span style="color:#f92672">+</span><span style="color:#111">newlen</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#f92672">&amp;</span><span style="color:#111">usable</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">newsh</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">s</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">newsh</span><span style="color:#f92672">+</span><span style="color:#111">hdrlen</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span> <span style="color:#00a8c8">else</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Since the header size changes, need to move the string forward,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * and can&#39;t use realloc */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 类型改变,需要重新申请内存，原内存释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">newsh</span> <span style="color:#f92672">=</span> <span style="color:#75af00">s_malloc_usable</span><span style="color:#111">(</span><span style="color:#111">hdrlen</span><span style="color:#f92672">+</span><span style="color:#111">newlen</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">,</span> <span style="color:#f92672">&amp;</span><span style="color:#111">usable</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">newsh</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">memcpy</span><span style="color:#111">((</span><span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">newsh</span><span style="color:#f92672">+</span><span style="color:#111">hdrlen</span><span style="color:#111">,</span> <span style="color:#111">s</span><span style="color:#111">,</span> <span style="color:#111">len</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">s_free</span><span style="color:#111">(</span><span style="color:#111">sh</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">s</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#00a8c8">char</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">newsh</span><span style="color:#f92672">+</span><span style="color:#111">hdrlen</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">type</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">sdssetlen</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">,</span> <span style="color:#111">len</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">usable</span> <span style="color:#f92672">=</span> <span style="color:#111">usable</span><span style="color:#f92672">-</span><span style="color:#111">hdrlen</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// type 是通过newlen判断得到的，而usable 是 hdrlen + newlen + 1 可能出现超出的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">usable</span> <span style="color:#f92672">&gt;</span> <span style="color:#75af00">sdsTypeMaxSize</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">usable</span> <span style="color:#f92672">=</span> <span style="color:#75af00">sdsTypeMaxSize</span><span style="color:#111">(</span><span style="color:#111">type</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">sdssetalloc</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">,</span> <span style="color:#111">usable</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">s</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><ol>
<li>首先判断newlen加上len是否超出可用的大小avail,没超就不扩容。</li>
<li>和之前不同，这一版本加入了greedy参数，来调节扩容策略，当greedy为1时，每次会扩大的比所需要的更多，这样可以减少扩容频率。而greedy为0时，就是节约内存</li>
<li>greedy为1时启用此策略: 如果newlen小于1MB,每次扩容二背，大于1MB时每次增加1MB。（每次2倍内存很快就耗尽了）</li>
<li>这里根据新的newlen来确定类型，如果类型不变，只需要扩展buf数组，而类型改变的话就需要重新申请内存。</li>
</ol>
<h2 id="跳表zskiplist">跳表zskiplist<a href="#%e8%b7%b3%e8%a1%a8zskiplist" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>对应的代码在 server.h 和 t_zset.c。</p>
<p>跳表可以看作链表加上都多层索引，一般每两个</p>
<p><img src="https://s2.loli.net/2022/11/25/87fPGrURAgdHzn3.jpg" alt="skiplist"></p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* ZSETs use a specialized version of Skiplists */</span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">typedef</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplistNode</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">sds</span> <span style="color:#111">ele</span><span style="color:#111">;</span> <span style="color:#75715e">// 存储字符串类型的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">double</span> <span style="color:#111">score</span><span style="color:#111">;</span> <span style="color:#75715e">// 储存排序的分值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">backward</span><span style="color:#111">;</span> <span style="color:#75715e">// 后向指针 头节点和第一个节点都为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplistLevel</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">forward</span><span style="color:#111">;</span> <span style="color:#75715e">// 指向本层下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">span</span><span style="color:#111">;</span> <span style="color:#75715e">// 跨度 指向本层下一个节点中间跨越的节点个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">}</span> <span style="color:#111">level</span><span style="color:#111">[];</span> <span style="color:#75715e">// 柔性数组，未分配内存时不占空间。初始化时，level 随机分配1~32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#111">}</span> <span style="color:#111">zskiplistNode</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">typedef</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplist</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">header</span><span style="color:#111">,</span> <span style="color:#f92672">*</span><span style="color:#111">tail</span><span style="color:#111">;</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">length</span><span style="color:#111">;</span> <span style="color:#75715e">// 除了头节点以外节点总数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">int</span> <span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#75715e">// 跳表的高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#111">}</span> <span style="color:#111">zskiplist</span><span style="color:#111">;</span>
</span></span></code></pre></div><p>用的图片是网图 <a href="https://zhuanlan.zhihu.com/p/26499803">链接</a>，其中obj一般为sds，在Redis6中已经改为sds ele。</p>
<p>可以从图和代码很清晰地看出跳跃表的结构。</p>
<p>跳跃表是Redis有序集合的底层实现方式之一，所以每个节点的ele存储有序集合的成员member值，score存储成员score值。所有节点的分值是按从小到大的方式排序的，当有序集合的成员分值相同时，节点会按member的字典序进行排序。</p>
<p>通过跳跃表结构体的属性我们可以看到，程序可以在O(1)的时间复杂度下，快速获取到跳跃表的头节点、尾节点、长度和高度。</p>
<h3 id="创建-1">创建<a href="#%e5%88%9b%e5%bb%ba-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>Redis通过zslRandomLevel函数随机生成一个1～32的值，作为新建节点的高度，值越大出现的概率越低。节点层高确定之后便不会再修改。生成随机层高的代码如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ZSKIPLIST 为 0.25
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#00a8c8">int</span> <span style="color:#75af00">zslRandomLevel</span><span style="color:#111">(</span><span style="color:#00a8c8">void</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">static</span> <span style="color:#00a8c8">const</span> <span style="color:#00a8c8">int</span> <span style="color:#111">threshold</span> <span style="color:#f92672">=</span> <span style="color:#111">ZSKIPLIST_P</span><span style="color:#f92672">*</span><span style="color:#111">RAND_MAX</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">level</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">while</span> <span style="color:#111">(</span><span style="color:#75af00">random</span><span style="color:#111">()</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">threshold</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">level</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里 ZSKIPLIST_MAXLEVEL 为32 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">return</span> <span style="color:#111">(</span><span style="color:#111">level</span><span style="color:#f92672">&lt;</span><span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">)</span> <span style="color:#f92672">?</span> <span style="color:#111">level</span> <span style="color:#111">:</span> <span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>当p=0.25时，跳跃表节点的期望层高为1/(1-0.25)≈1.33。</p>
<p>下面是创建函数</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Create a skiplist node with the specified number of levels.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The SDS string &#39;ele&#39; is referenced by the node after the call. */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#75af00">zslCreateNode</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">level</span><span style="color:#111">,</span> <span style="color:#00a8c8">double</span> <span style="color:#111">score</span><span style="color:#111">,</span> <span style="color:#111">sds</span> <span style="color:#111">ele</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">zn</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#75715e">// level 柔性数组加上头大小 来申请内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75af00">zmalloc</span><span style="color:#111">(</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#111">zn</span><span style="color:#111">)</span><span style="color:#f92672">+</span><span style="color:#111">level</span><span style="color:#f92672">*</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#00a8c8">struct</span> <span style="color:#111">zskiplistLevel</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zn</span><span style="color:#f92672">-&gt;</span><span style="color:#111">score</span> <span style="color:#f92672">=</span> <span style="color:#111">score</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zn</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ele</span> <span style="color:#f92672">=</span> <span style="color:#111">ele</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">zn</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Create a new skiplist. */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">zskiplist</span> <span style="color:#f92672">*</span><span style="color:#75af00">zslCreate</span><span style="color:#111">(</span><span style="color:#00a8c8">void</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">j</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zskiplist</span> <span style="color:#f92672">*</span><span style="color:#111">zsl</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zmalloc</span><span style="color:#111">(</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#111">zsl</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">length</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 头节点的level是最大层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zslCreateNode</span><span style="color:#111">(</span><span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">,</span><span style="color:#ae81ff">0</span><span style="color:#111">,</span><span style="color:#111">NULL</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">j</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">j</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">;</span> <span style="color:#111">j</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#f92672">-&gt;</span><span style="color:#111">backward</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tail</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">zsl</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>头节点是一个特殊的节点，不存储有序集合的member信息。头节点是跳跃表中第一个插入的节点，其level数组的每项forward都为NULL, span值都为0</p>
<h3 id="插入">插入<a href="#%e6%8f%92%e5%85%a5" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Insert a new node in the skiplist. Assumes the element does not already
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * exist (up to the caller to enforce that). The skiplist takes ownership
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * of the passed SDS string &#39;ele&#39;. */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#75af00">zslInsert</span><span style="color:#111">(</span><span style="color:#111">zskiplist</span> <span style="color:#f92672">*</span><span style="color:#111">zsl</span><span style="color:#111">,</span> <span style="color:#00a8c8">double</span> <span style="color:#111">score</span><span style="color:#111">,</span> <span style="color:#111">sds</span> <span style="color:#111">ele</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录每层所能到达的最右边节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">],</span> <span style="color:#f92672">*</span><span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录每层从header到update[i}所需的步长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">i</span><span style="color:#111">,</span> <span style="color:#111">level</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断score 是不是NAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75af00">serverAssert</span><span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#75af00">isnan</span><span style="color:#111">(</span><span style="color:#111">score</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从最高层索引开始遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">--</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* store rank that is crossed to reach the insert position */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 当在最高层时，先将rank赋值为0，先假设
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">i</span> <span style="color:#f92672">==</span> <span style="color:#111">(</span><span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">)</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在第i层一直向前移动比较,因为是按照score 从小到大排列的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 找到这层大于插入score 的位置然后下移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#00a8c8">while</span> <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">score</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">score</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">score</span> <span style="color:#f92672">==</span> <span style="color:#111">score</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75af00">sdscmp</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ele</span><span style="color:#111">,</span><span style="color:#111">ele</span><span style="color:#111">)</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span><span style="color:#111">)))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新总的span
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">+=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录这层的终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* we assume the element is not already inside, since we allow duplicated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * scores, reinserting the same element should never happen since the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * caller of zslInsert() should test in the hash table if the element is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * already inside or not. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// zslInsert不能应用在插入节点已经存在的情况下。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以不用检查存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//为插入节点计算随机层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">level</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zslRandomLevel</span><span style="color:#111">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//大于原来层高的部分，只需要调整header就行。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">level</span> <span style="color:#f92672">&gt;</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 为啥是这个？可能是用来占位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">length</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span> <span style="color:#f92672">=</span> <span style="color:#111">level</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zslCreateNode</span><span style="color:#111">(</span><span style="color:#111">level</span><span style="color:#111">,</span><span style="color:#111">score</span><span style="color:#111">,</span><span style="color:#111">ele</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入到每层最右侧能到达的节点之后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">=</span> <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* update span covered by update[i] as x is inserted here */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入节点每层的span更新,这个看下图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">=</span> <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">-</span> <span style="color:#111">(</span><span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">-</span> <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">-</span> <span style="color:#111">rank</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">])</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* increment span for untouched levels */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">backward</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">==</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#111">)</span> <span style="color:#f92672">?</span> <span style="color:#111">NULL</span> <span style="color:#f92672">:</span> <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">backward</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tail</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">length</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>下图来源于 <a href="https://zhuanlan.zhihu.com/p/56941754">链接</a></p>
<p><img src="https://s2.loli.net/2022/11/26/FHEMRScINYyX72U.png" alt=""></p>
<p>以节点19插入为例，其中
黑色箭头的表示的跨度为update[i]-&gt;level[i].span
蓝色箭头表示的跨度为rank[0] - rank[i]即节点19在level_0的update[0]为11，
在level_1的update[1]为7，rank[0] - rank[i]为节点7与节点11之间的跨度
绿色箭头表示的跨度为节点19到节点37的span</p>
<h3 id="删除">删除<a href="#%e5%88%a0%e9%99%a4" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>首先查找到对应的节点，将每层最右边到达的节点记录下来，对应的update。
辅助函数:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">void</span> <span style="color:#75af00">zslDeleteNode</span><span style="color:#111">(</span><span style="color:#111">zskiplist</span> <span style="color:#f92672">*</span><span style="color:#111">zsl</span><span style="color:#111">,</span> <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">x</span><span style="color:#111">,</span> <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">**</span><span style="color:#111">update</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调整对应的span和forward
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">int</span> <span style="color:#111">i</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">==</span> <span style="color:#111">x</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">+=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span> <span style="color:#00a8c8">else</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">span</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">backward</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">backward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span> <span style="color:#00a8c8">else</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tail</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">backward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调整level 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">while</span><span style="color:#111">(</span><span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#f92672">--</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">length</span><span style="color:#f92672">--</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>删除函数:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">int</span> <span style="color:#75af00">zslDelete</span><span style="color:#111">(</span><span style="color:#111">zskiplist</span> <span style="color:#f92672">*</span><span style="color:#111">zsl</span><span style="color:#111">,</span> <span style="color:#00a8c8">double</span> <span style="color:#111">score</span><span style="color:#111">,</span> <span style="color:#111">sds</span> <span style="color:#111">ele</span><span style="color:#111">,</span> <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">**</span><span style="color:#111">node</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zskiplistNode</span> <span style="color:#f92672">*</span><span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">ZSKIPLIST_MAXLEVEL</span><span style="color:#111">],</span> <span style="color:#f92672">*</span><span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">i</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//查找位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">header</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#111">zsl</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">--</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">while</span> <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">score</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">score</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">score</span> <span style="color:#f92672">==</span> <span style="color:#111">score</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                     <span style="color:#75af00">sdscmp</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ele</span><span style="color:#111">,</span><span style="color:#111">ele</span><span style="color:#111">)</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span><span style="color:#111">)))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 保存每层最右边的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">update</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* We may have multiple elements with the same score, what we need
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * is to find the element with both the right score and object. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可能同一个score有多个ele
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">level</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">].</span><span style="color:#111">forward</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">x</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#111">score</span> <span style="color:#f92672">==</span> <span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">score</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#75af00">sdscmp</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ele</span><span style="color:#111">,</span><span style="color:#111">ele</span><span style="color:#111">)</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">zslDeleteNode</span><span style="color:#111">(</span><span style="color:#111">zsl</span><span style="color:#111">,</span> <span style="color:#111">x</span><span style="color:#111">,</span> <span style="color:#111">update</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#111">node</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75af00">zslFreeNode</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span><span style="color:#111">node</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">return</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#75715e">/* not found */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><h2 id="压缩列表">压缩列表<a href="#%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>具体的实现在ziplist.h和ziplist.c</p>
<p>压缩列表是Redis中一种高效利用内存的数据结构，用来储存字符串和数字，它的push和pop操作都是  <strong>O(1)</strong> 。Redis的有序集合、散列和列表都直接或者间接使用了压缩列表。当有序集合或散列表的元素个数比较少，且元素都是短字符串时，Redis便使用压缩列表作为其底层数据存储结构。列表使用快速链表（quicklist）数据结构存储，而快速链表就是双向链表与压缩列表的组合。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ziplist 结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&lt;</span><span style="color:#111">zlbytes</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">zltail</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">zllen</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">entry</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">entry</span><span style="color:#f92672">&gt;</span> <span style="color:#111">...</span> <span style="color:#f92672">&lt;</span><span style="color:#111">entry</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">zlend</span><span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>这里的所有结构都是按照小端存储。</p>
<ul>
<li>zlbytes: 压缩列表的字节长度，占4个字节，因此压缩列表最多有$2^{32}-1$个字节。这个设计是为了resize时不必遍历整个列表</li>
<li>zltail:  压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节，这个设计可以使pop操作不必要遍历全部。</li>
<li>zllen: 压缩列表的元素个数，占2个字节。zllen无法存储元素个数超过65535（$2^{16}-1$）的压缩列表，必须遍历整个压缩列表才能获取到元素个数。</li>
<li>zlend: 压缩列表的结尾，占1个字节，恒为0xFF。</li>
</ul>
<p>这里可以清楚地感受到C语言对内存的掌控，通过指针位移来获取结构信息。这里使用宏又是C语言的一个特色，比起inline只是建议编译器内联，宏真正是内联，对于一些细小而频繁的操作提高了性能。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Return total bytes a ziplist is composed of. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Return the offset of the last item inside the ziplist. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Return the length of a ziplist, or UINT16_MAX if the length cannot be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * determined without scanning the whole ziplist. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* The size of a ziplist header: two 32 bit integers for the total
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * bytes count and last item offset. One 16 bit integer for the number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * of items field. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Size of the &#34;end of ziplist&#34; entry. Just one byte. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_END_SIZE        (sizeof(uint8_t))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Return the pointer to the first entry of a ziplist. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Return the pointer to the last entry of a ziplist, using the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * last entry offset inside the ziplist header. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Return the pointer to the last byte of a ziplist, which is, the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * end of ziplist FF entry. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-ZIPLIST_END_SIZE)
</span></span></span></code></pre></div><p>对于 <entry> 结构如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#111">prevlen</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">encoding</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#111">entry</span><span style="color:#f92672">-</span><span style="color:#111">data</span><span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>previous_entry_length字段表示前一个元素的字节长度，占1个或者5个字节，当前一个元素的长度小于254字节时，用1个字节表示；当前一个元素的长度大于或等于254字节时，用5个字节来表示。而此时previous_entry_length字段的第1个字节是固定的0xFE，后面4个字节才真正表示前一个元素的长度。假设已知当前元素的首地址为p，那么p-previous_entry_length就是前一个元素的首地址，从而实现压缩列表从尾到头的遍历。</p>
<p>encoding字段表示当前元素的编码，即content字段存储的数据类型（整数或者字节数组），数据内容存储在content字段。为了节约内存，encoding字段同样长度可变。</p>
<p><img src="https://s2.loli.net/2022/11/26/6gMtVLmx9udXpS3.png" alt=""></p>
<p>Redis使用宏来表示</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_MASK 0xc0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_MASK 0x30
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_06B (0 &lt;&lt; 6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_14B (1 &lt;&lt; 6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_32B (2 &lt;&lt; 6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_8B 0xfe
</span></span></span></code></pre></div><p><strong>这里使用位运算来代表类型</strong>，既节省了内存又提高了性能。</p>
<h3 id="结构">结构<a href="#%e7%bb%93%e6%9e%84" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">typedef</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">zlentry</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">prevrawlensize</span><span style="color:#111">;</span> <span style="color:#75715e">/* Bytes used to encode the previous entry len*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">prevrawlen</span><span style="color:#111">;</span>     <span style="color:#75715e">/* Previous entry len. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">lensize</span><span style="color:#111">;</span>        <span style="color:#75715e">/* Bytes used to encode this entry type/len.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    For example strings have a 1, 2 or 5 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    header. Integers always use a single byte.*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">len</span><span style="color:#111">;</span>            <span style="color:#75715e">/* Bytes used to represent the actual entry.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    For strings this is just the string length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    while for integers it is 1, 2, 3, 4, 8 or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    0 (for 4 bit immediate) depending on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    number range. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">headersize</span><span style="color:#111">;</span>     <span style="color:#75715e">/* prevrawlensize + lensize. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#111">encoding</span><span style="color:#111">;</span>      <span style="color:#75715e">/* Set to ZIP_STR_* or ZIP_INT_* depending on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    the entry encoding. However for 4 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    immediate integers this can assume a range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    of values and must be range-checked. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#f92672">*</span><span style="color:#111">p</span><span style="color:#111">;</span>            <span style="color:#75715e">/* Pointer to the very start of the entry, that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                    is, this points to prev-entry-len field. */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span> <span style="color:#111">zlentry</span><span style="color:#111">;</span>
</span></span></code></pre></div><p>对于压缩列表的任意元素，获取前一个元素的长度、判断存储的数据类型、获取数据内容都需要经过复杂的解码运算。解码后的结果应该被缓存起来，为此定义了结构体zlentry，用于表示解码后的压缩列表元素。</p>
<p>解码操作，主要用宏实现:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">static</span> <span style="color:#00a8c8">inline</span> <span style="color:#00a8c8">void</span> <span style="color:#75af00">zipEntry</span><span style="color:#111">(</span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#f92672">*</span><span style="color:#111">p</span><span style="color:#111">,</span> <span style="color:#111">zlentry</span> <span style="color:#f92672">*</span><span style="color:#111">e</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">ZIP_DECODE_PREVLEN</span><span style="color:#111">(</span><span style="color:#111">p</span><span style="color:#111">,</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">prevrawlensize</span><span style="color:#111">,</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">prevrawlen</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">ZIP_ENTRY_ENCODING</span><span style="color:#111">(</span><span style="color:#111">p</span> <span style="color:#f92672">+</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">prevrawlensize</span><span style="color:#111">,</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">encoding</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">ZIP_DECODE_LENGTH</span><span style="color:#111">(</span><span style="color:#111">p</span> <span style="color:#f92672">+</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">prevrawlensize</span><span style="color:#111">,</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">encoding</span><span style="color:#111">,</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">lensize</span><span style="color:#111">,</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">len</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">assert</span><span style="color:#111">(</span><span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">lensize</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span><span style="color:#111">);</span> <span style="color:#75715e">/* check that encoding was valid. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">headersize</span> <span style="color:#f92672">=</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">prevrawlensize</span> <span style="color:#f92672">+</span> <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">lensize</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">e</span><span style="color:#f92672">-&gt;</span><span style="color:#111">p</span> <span style="color:#f92672">=</span> <span style="color:#111">p</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>这里主要就是对字节的读取，可以去看源代码。</p>
<h3 id="操作">操作<a href="#%e6%93%8d%e4%bd%9c" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<h4 id="创建-2">创建<a href="#%e5%88%9b%e5%bb%ba-2" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Create a new empty ziplist. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 先申请初始的空间(4+4+2+1),再对zlbytes,zltail,zllen,zlend逐个初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#f92672">*</span><span style="color:#75af00">ziplistNew</span><span style="color:#111">(</span><span style="color:#00a8c8">void</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">int</span> <span style="color:#111">bytes</span> <span style="color:#f92672">=</span> <span style="color:#111">ZIPLIST_HEADER_SIZE</span><span style="color:#f92672">+</span><span style="color:#111">ZIPLIST_END_SIZE</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#f92672">*</span><span style="color:#111">zl</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zmalloc</span><span style="color:#111">(</span><span style="color:#111">bytes</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">ZIPLIST_BYTES</span><span style="color:#111">(</span><span style="color:#111">zl</span><span style="color:#111">)</span> <span style="color:#f92672">=</span> <span style="color:#75af00">intrev32ifbe</span><span style="color:#111">(</span><span style="color:#111">bytes</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">ZIPLIST_TAIL_OFFSET</span><span style="color:#111">(</span><span style="color:#111">zl</span><span style="color:#111">)</span> <span style="color:#f92672">=</span> <span style="color:#75af00">intrev32ifbe</span><span style="color:#111">(</span><span style="color:#111">ZIPLIST_HEADER_SIZE</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">ZIPLIST_LENGTH</span><span style="color:#111">(</span><span style="color:#111">zl</span><span style="color:#111">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">zl</span><span style="color:#111">[</span><span style="color:#111">bytes</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">ZIP_END</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">zl</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><h4 id="插入元素">插入元素<a href="#%e6%8f%92%e5%85%a5%e5%85%83%e7%b4%a0" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<ol>
<li>编码。计算previous_entry_length字段、encoding字段和content字段的内容。</li>
</ol>
<h2 id="字典">字典<a href="#%e5%ad%97%e5%85%b8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<h3 id="结构-1">结构<a href="#%e7%bb%93%e6%9e%84-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>节点:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">typedef</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">dictEntry</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">key</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 节省内存 不同场景下使用不同字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">union</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">val</span><span style="color:#111">;</span> <span style="color:#75715e">// db.dict 储存值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#00a8c8">uint64_t</span> <span style="color:#111">u64</span><span style="color:#111">;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">int64_t</span> <span style="color:#111">s64</span><span style="color:#111">;</span>  <span style="color:#75715e">// db.expires 储存过期时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#00a8c8">double</span> <span style="color:#111">d</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span> <span style="color:#111">v</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 单链表法 解决哈希冲突。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">struct</span> <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">next</span><span style="color:#111">;</span>     <span style="color:#75715e">/* Next entry in the same hash bucket. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">metadata</span><span style="color:#111">[];</span>           <span style="color:#75715e">/* An arbitrary number of bytes (starting at a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                 * pointer-aligned address) of size as returned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                 * by dictType&#39;s dictEntryMetadataBytes(). */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span> <span style="color:#111">dictEntry</span><span style="color:#111">;</span>
</span></span></code></pre></div><p>可以看出是使用链表法来解决hash冲突的。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">struct</span> <span style="color:#111">dict</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dictType</span> <span style="color:#f92672">*</span><span style="color:#111">type</span><span style="color:#111">;</span> <span style="color:#75715e">// 对应特定类型操作函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#111">dictEntry</span> <span style="color:#f92672">**</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">2</span><span style="color:#111">];</span> <span style="color:#75715e">// 哈希表。有两个，一个正常使用，另外一个在rehash时使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">2</span><span style="color:#111">];</span> <span style="color:#75715e">// 记录每个哈希表被使用的数目。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">long</span> <span style="color:#111">rehashidx</span><span style="color:#111">;</span> <span style="color:#75715e">/* rehashing not in progress if rehashidx == -1 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Keep small vars at end for optimal (minimal) struct padding */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int16_t</span> <span style="color:#111">pauserehash</span><span style="color:#111">;</span> <span style="color:#75715e">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// size 的 系数，size 是2 的N次幂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">signed</span> <span style="color:#00a8c8">char</span> <span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">2</span><span style="color:#111">];</span> <span style="color:#75715e">/* exponent of size. (size = 1&lt;&lt;exp) */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">};</span>
</span></span></code></pre></div><p>这里可以看到一个dictType 用来对应特定类型的操作函数,这些函数体现了面向对象编程的思想，会在后面合适的时机用到。</p>
<p>比如找个hashFunction 用来控制dict使用的hash函数，默认为siphash。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75af00">typedef</span> <span style="color:#00a8c8">struct</span> <span style="color:#75af00">dictType</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">uint64_t</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">hashFunction</span><span style="color:#111">)(</span><span style="color:#00a8c8">const</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">key</span><span style="color:#111">);</span> <span style="color:#75715e">// hash函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">keyDup</span><span style="color:#111">)(</span><span style="color:#75af00">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">key</span><span style="color:#111">);</span> <span style="color:#75715e">// key的 复制函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">valDup</span><span style="color:#111">)(</span><span style="color:#75af00">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">obj</span><span style="color:#111">);</span> <span style="color:#75715e">// val 的复制函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">keyCompare</span><span style="color:#111">)(</span><span style="color:#75af00">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">key1</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">key2</span><span style="color:#111">);</span> <span style="color:#75715e">// key 对比函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">void</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">keyDestructor</span><span style="color:#111">)(</span><span style="color:#75af00">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">d</span><span style="color:#111">,</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">key</span><span style="color:#111">);</span> <span style="color:#75715e">// key 销毁函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">void</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">valDestructor</span><span style="color:#111">)(</span><span style="color:#75af00">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">d</span><span style="color:#111">,</span> <span style="color:#75af00">void</span> <span style="color:#f92672">*</span><span style="color:#75af00">obj</span><span style="color:#111">);</span> <span style="color:#75715e">// val 销毁函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">expandAllowed</span><span style="color:#111">)(</span><span style="color:#75af00">size_t</span> <span style="color:#75af00">moreMem</span><span style="color:#111">,</span> <span style="color:#75af00">double</span> <span style="color:#75af00">usedRatio</span><span style="color:#111">);</span> <span style="color:#75715e">//扩展函数 </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Allow a dictEntry to carry extra caller-defined metadata.  The
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * extra memory is initialized to 0 when a dictEntry is allocated. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">size_t</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#75af00">dictEntryMetadataBytes</span><span style="color:#111">)(</span><span style="color:#75af00">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">d</span><span style="color:#111">);</span> <span style="color:#75715e">// 元数据</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span> <span style="color:#75af00">dictType</span><span style="color:#111">;</span>
</span></span></code></pre></div><h3 id="创建-3">创建<a href="#%e5%88%9b%e5%bb%ba-3" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>先申请空间，再初始化参数</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Reset hash table parameters already initialized with _dictInit()*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">static</span> <span style="color:#00a8c8">void</span> <span style="color:#75af00">_dictReset</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">htidx</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#111">htidx</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#111">htidx</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#111">htidx</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Create a new hash table */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#75af00">dictCreate</span><span style="color:#111">(</span><span style="color:#111">dictType</span> <span style="color:#f92672">*</span><span style="color:#111">type</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zmalloc</span><span style="color:#111">(</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">_dictInit</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span><span style="color:#111">type</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">d</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Initialize the hash table */</span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">int</span> <span style="color:#75af00">_dictInit</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">dictType</span> <span style="color:#f92672">*</span><span style="color:#111">type</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">_dictReset</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#ae81ff">0</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">_dictReset</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#ae81ff">1</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">type</span> <span style="color:#f92672">=</span> <span style="color:#111">type</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">pauserehash</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_OK</span><span style="color:#111">;</span> <span style="color:#75715e">// 使用一些宏来反馈结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#111">}</span>
</span></span></code></pre></div><h3 id="增加与扩容">增加与扩容<a href="#%e5%a2%9e%e5%8a%a0%e4%b8%8e%e6%89%a9%e5%ae%b9" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>这里先提前讲一下Rehash的概念，便于理解增加扩容中的一些操作:</p>
<p>扩容后，字典容量及掩码值会发生改变，同一个键与掩码经位运算后得到的索引值就会发生改变，从而导致根据键查找不到值的情况。解决这个问题的方法是，<strong>新扩容的内存放到一个全新的Hash表中（ht[1]），并给字典打上在进行rehash操作中的标识（即rehashidx! =-1）</strong>。此后，新添加的键值对都往新的Hash表中存储；而修改、删除、查找操作需要在ht[0]、ht[1]中进行检查，然后再决定去对哪个Hash表操作。除此之外，还需要把老Hash表（ht[0]）中的数据重新计算索引值后全部迁移插入到新的Hash表(ht[1])中，此迁移过程称作rehash。</p>
<p>先看增加单个entry的操作:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Add an element to the target hash table */</span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">int</span> <span style="color:#75af00">dictAdd</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">key</span><span style="color:#111">,</span> <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">val</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">entry</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictAddRaw</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span><span style="color:#111">key</span><span style="color:#111">,</span><span style="color:#111">NULL</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#111">entry</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_ERR</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">dictSetVal</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">entry</span><span style="color:#111">,</span> <span style="color:#111">val</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_OK</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#75af00">dictAddRaw</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">key</span><span style="color:#111">,</span> <span style="color:#111">dictEntry</span> <span style="color:#f92672">**</span><span style="color:#111">existing</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">long</span> <span style="color:#111">index</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">entry</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">htidx</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果正在rehash,在add时进行一步rehash，这里是将大范围的rehash分散来减小资源集中消耗
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#75af00">dictIsRehashing</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">))</span> <span style="color:#75af00">_dictRehashStep</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Get the index of the new element, or -1 if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * the element already exists. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">((</span><span style="color:#111">index</span> <span style="color:#f92672">=</span> <span style="color:#75af00">_dictKeyIndex</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">key</span><span style="color:#111">,</span> <span style="color:#75af00">dictHashKey</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span><span style="color:#111">key</span><span style="color:#111">),</span> <span style="color:#111">existing</span><span style="color:#111">))</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">return</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Allocate the memory and store the new entry.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Insert the element in top, with the assumption that in a database
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * system it is more likely that recently added entries are accessed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * more frequently. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">htidx</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictIsRehashing</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">)</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">size_t</span> <span style="color:#111">metasize</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictMetadataSize</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">entry</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zmalloc</span><span style="color:#111">(</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#111">entry</span><span style="color:#111">)</span> <span style="color:#f92672">+</span> <span style="color:#111">metasize</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">metasize</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">memset</span><span style="color:#111">(</span><span style="color:#75af00">dictMetadata</span><span style="color:#111">(</span><span style="color:#111">entry</span><span style="color:#111">),</span> <span style="color:#ae81ff">0</span><span style="color:#111">,</span> <span style="color:#111">metasize</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 插入在顶部:根据时空局限性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">entry</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#111">htidx</span><span style="color:#111">][</span><span style="color:#111">index</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#111">htidx</span><span style="color:#111">][</span><span style="color:#111">index</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">entry</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#111">htidx</span><span style="color:#111">]</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Set the hash entry fields. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75af00">dictSetKey</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">entry</span><span style="color:#111">,</span> <span style="color:#111">key</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">entry</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>可以看出，add调用了一个底层的addraw函数。addraw首先使用dictkeyindex来查找一个合适的插入位置，如果这个key已经存在就退出add操作。然后确定是否在rehash,上面我们讲过如果在rehash那么 <strong>新添加的键值对都往新的Hash表中存储</strong>。后面就申请空间在相应位置顶部插入，这是数据库时空局限性的体现。</p>
<p>这里看一下dictSetKey和dictSetVal:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define dictSetKey(d, entry, _key_) do { \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    if ((d)-&gt;type-&gt;keyDup) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        (entry)-&gt;key = (d)-&gt;type-&gt;keyDup((d), _key_); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    else \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        (entry)-&gt;key = (_key_); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">} while(0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define dictSetVal(d, entry, _val_) do { \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    if ((d)-&gt;type-&gt;valDup) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        (entry)-&gt;v.val = (d)-&gt;type-&gt;valDup((d), _val_); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    else \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        (entry)-&gt;v.val = (_val_); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">} while(0)
</span></span></span></code></pre></div><p>可以看出是用宏的形式调用dict的dicttype函数，也就是说这些操作是可以调整的。</p>
<p>扩容操作:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 将d扩容到2^size的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#00a8c8">int</span> <span style="color:#75af00">_dictExpand</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">size</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span><span style="color:#f92672">*</span> <span style="color:#111">malloc_failed</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">malloc_failed</span><span style="color:#111">)</span> <span style="color:#f92672">*</span><span style="color:#111">malloc_failed</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* the size is invalid if it is smaller than the number of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * elements already inside the hash table */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#75af00">dictIsRehashing</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">)</span> <span style="color:#f92672">||</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">&gt;</span> <span style="color:#111">size</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_ERR</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* the new hash table */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dictEntry</span> <span style="color:#f92672">**</span><span style="color:#111">new_ht_table</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">new_ht_used</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">signed</span> <span style="color:#00a8c8">char</span> <span style="color:#111">new_ht_size_exp</span> <span style="color:#f92672">=</span> <span style="color:#75af00">_dictNextExp</span><span style="color:#111">(</span><span style="color:#111">size</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Detect overflows */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">size_t</span> <span style="color:#111">newsize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1ul</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#111">new_ht_size_exp</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 后者判断在什么时候成立?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">newsize</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">size</span> <span style="color:#f92672">||</span> <span style="color:#111">newsize</span> <span style="color:#f92672">*</span> <span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#111">dictEntry</span><span style="color:#f92672">*</span><span style="color:#111">)</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">newsize</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_ERR</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Rehashing to the same table size is not useful. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">new_ht_size_exp</span> <span style="color:#f92672">==</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">])</span> <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_ERR</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Allocate the new hash table and initialize all pointers to NULL */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">malloc_failed</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">new_ht_table</span> <span style="color:#f92672">=</span> <span style="color:#75af00">ztrycalloc</span><span style="color:#111">(</span><span style="color:#111">newsize</span><span style="color:#f92672">*</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#111">dictEntry</span><span style="color:#f92672">*</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span><span style="color:#111">malloc_failed</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_table</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#111">malloc_failed</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_ERR</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span> <span style="color:#00a8c8">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">new_ht_table</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zcalloc</span><span style="color:#111">(</span><span style="color:#111">newsize</span><span style="color:#f92672">*</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#111">dictEntry</span><span style="color:#f92672">*</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新的hash表被使用的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">new_ht_used</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Is this the first initialization? If so it&#39;s not really a rehashing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * we just set the first hash table so that it can accept keys. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_size_exp</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_used</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_table</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_OK</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Prepare a second hash table for incremental rehashing */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_size_exp</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_used</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">new_ht_table</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">DICT_OK</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>首先判断是否在rehash，在rehash中不能扩容。然后创建一个新的hash table，这个newsize是2的n次幂。expand操作在刚开始初始化时会使用，也会在这里做一个判断。更常用的是在扩容后进行rehash操作。</p>
<p>获得size的函数:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 确保hash cap 为2的N次幂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#00a8c8">static</span> <span style="color:#00a8c8">signed</span> <span style="color:#00a8c8">char</span> <span style="color:#75af00">_dictNextExp</span><span style="color:#111">(</span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#111">size</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">char</span> <span style="color:#111">e</span> <span style="color:#f92672">=</span> <span style="color:#111">DICT_HT_INITIAL_EXP</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">size</span> <span style="color:#f92672">&gt;=</span> <span style="color:#111">LONG_MAX</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">(</span><span style="color:#ae81ff">8</span><span style="color:#f92672">*</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#00a8c8">long</span><span style="color:#111">)</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1 &lt;&lt; e == 1 * 2^e  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 找到一个大于size 的2^e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">while</span><span style="color:#111">(</span><span style="color:#ae81ff">1</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(((</span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span><span style="color:#111">)</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#111">e</span><span style="color:#111">)</span> <span style="color:#f92672">&gt;=</span> <span style="color:#111">size</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">return</span> <span style="color:#111">e</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">e</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><h3 id="渐进式rehash">渐进式Rehash<a href="#%e6%b8%90%e8%bf%9b%e5%bc%8frehash" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>直接看函数:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">int</span> <span style="color:#75af00">dictRehash</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">n</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">empty_visits</span> <span style="color:#f92672">=</span> <span style="color:#111">n</span><span style="color:#f92672">*</span><span style="color:#ae81ff">10</span><span style="color:#111">;</span> <span style="color:#75715e">/* Max number of empty buckets to visit. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#75af00">dictIsRehashing</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">))</span> <span style="color:#00a8c8">return</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">while</span><span style="color:#111">(</span><span style="color:#111">n</span><span style="color:#f92672">--</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">de</span><span style="color:#111">,</span> <span style="color:#f92672">*</span><span style="color:#111">nextde</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Note that rehashidx can&#39;t overflow as we are sure there are more
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * elements because ht[0].used != 0 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">assert</span><span style="color:#111">(</span><span style="color:#75af00">DICTHT_SIZE</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">])</span> <span style="color:#f92672">&gt;</span> <span style="color:#111">(</span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span><span style="color:#111">)</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">while</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">][</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span><span style="color:#111">]</span> <span style="color:#f92672">==</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">--</span><span style="color:#111">empty_visits</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">de</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">][</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Move all the keys in this bucket from the old to the new hash HT */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">while</span><span style="color:#111">(</span><span style="color:#111">de</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">uint64_t</span> <span style="color:#111">h</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">nextde</span> <span style="color:#f92672">=</span> <span style="color:#111">de</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* Get the index in the new hash table */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">h</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictHashKey</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">de</span><span style="color:#f92672">-&gt;</span><span style="color:#111">key</span><span style="color:#111">)</span> <span style="color:#f92672">&amp;</span> <span style="color:#75af00">DICTHT_SIZE_MASK</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">]);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">de</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">][</span><span style="color:#111">h</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">][</span><span style="color:#111">h</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">de</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span><span style="color:#f92672">--</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">de</span> <span style="color:#f92672">=</span> <span style="color:#111">nextde</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">][</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Check if we already rehashed the whole table... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">zfree</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Copy the new ht onto the old one */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">_dictReset</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#ae81ff">1</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">rehashidx</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">return</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* More to rehash... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>rehash除了扩容时会触发，缩容时也会触发。Redis整个rehash的实现，主要分为如下几步完成。</p>
<ol>
<li>给Hash表ht[1]申请足够的空间；扩容时空间大小为当前容量<em>2，即d-&gt;ht[0]. used</em>2；当使用量不到总空间10%时，则进行缩容。缩容时空间大小则为能恰好包含d-&gt;ht[0].used个节点的2^N次方幂整数，并把字典中字段rehashidx标识为0</li>
<li>进行rehash操作调用的是dictRehash函数，重新计算ht[0]中每个键的Hash值与索引值（重新计算就叫rehash），依次添加到新的Hash表ht[1]，并把老Hash表中该键值对删除。把字典中字段rehashidx字段修改为Hash表ht[0]中正在进行rehash操作节点的索引值.</li>
<li>rehash操作后，清空ht[0]，然后对调一下ht[1]与ht[0]的值，并把字典中rehashidx字段标识为-1。</li>
</ol>
<p>我们知道，Redis可以提供高性能的线上服务，而且是单进程模式，当数据库中键值对数量达到了百万、千万、亿级别时，整个rehash过程将非常缓慢，如果不优化rehash过程，可能会造成很严重的服务不可用现象。Redis优化的思想很巧妙，利用分而治之的思想了进行rehash操作，大致的步骤如下。</p>
<p>执行插入、删除、查找、修改等操作前，都先判断当前字典rehash操作是否在进行中，进行中则调用dictRehashStep函数进行rehash操作（每次只对1个节点进行rehash操作，共执行1次）。除这些操作之外，当服务空闲时，如果当前字典也需要进行rehsh操作，则会调用incrementallyRehash函数进行批量rehash操作（每次对100个节点进行rehash操作，共执行1毫秒）。在经历N次rehash操作后，整个ht[0]的数据都会迁移到ht[1]中，这样做的好处就把是本应集中处理的时间分散到了上百万、千万、亿次操作中，所以其耗时可忽略不计。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* This function performs just a step of rehashing, and only if hashing has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * not been paused for our hash table. When we have iterators in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * middle of a rehashing we can&#39;t mess with the two hash tables otherwise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * some elements can be missed or duplicated.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This function is called by common lookup or update operations in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * dictionary so that the hash table automatically migrates from H1 to H2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * while it is actively used. */</span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">static</span> <span style="color:#00a8c8">void</span> <span style="color:#75af00">_dictRehashStep</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">pauserehash</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#75af00">dictRehash</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span><span style="color:#ae81ff">1</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><h3 id="删除-1">删除<a href="#%e5%88%a0%e9%99%a4-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">static</span> <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#75af00">dictGenericDelete</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#00a8c8">void</span> <span style="color:#f92672">*</span><span style="color:#111">key</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">nofree</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">uint64_t</span> <span style="color:#111">h</span><span style="color:#111">,</span> <span style="color:#111">idx</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">he</span><span style="color:#111">,</span> <span style="color:#f92672">*</span><span style="color:#111">prevHe</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">table</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* dict is empty */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#75af00">dictSize</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">)</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#111">)</span> <span style="color:#00a8c8">return</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#75af00">dictIsRehashing</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">))</span> <span style="color:#75af00">_dictRehashStep</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">h</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictHashKey</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">key</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">table</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">table</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#111">;</span> <span style="color:#111">table</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">idx</span> <span style="color:#f92672">=</span> <span style="color:#111">h</span> <span style="color:#f92672">&amp;</span> <span style="color:#75af00">DICTHT_SIZE_MASK</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#111">table</span><span style="color:#111">]);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">he</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#111">table</span><span style="color:#111">][</span><span style="color:#111">idx</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">prevHe</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#00a8c8">while</span><span style="color:#111">(</span><span style="color:#111">he</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">key</span><span style="color:#f92672">==</span><span style="color:#111">he</span><span style="color:#f92672">-&gt;</span><span style="color:#111">key</span> <span style="color:#f92672">||</span> <span style="color:#75af00">dictCompareKeys</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">key</span><span style="color:#111">,</span> <span style="color:#111">he</span><span style="color:#f92672">-&gt;</span><span style="color:#111">key</span><span style="color:#111">))</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* Unlink the element from the list */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">prevHe</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#111">prevHe</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span> <span style="color:#f92672">=</span> <span style="color:#111">he</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#00a8c8">else</span> <span style="color:#75715e">// 在bucket顶部,直接略过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#111">table</span><span style="color:#111">][</span><span style="color:#111">idx</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">he</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#111">nofree</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75af00">dictFreeUnlinkedEntry</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">,</span> <span style="color:#111">he</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#111">table</span><span style="color:#111">]</span><span style="color:#f92672">--</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#00a8c8">return</span> <span style="color:#111">he</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">prevHe</span> <span style="color:#f92672">=</span> <span style="color:#111">he</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">he</span> <span style="color:#f92672">=</span> <span style="color:#111">he</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#75af00">dictIsRehashing</span><span style="color:#111">(</span><span style="color:#111">d</span><span style="color:#111">))</span> <span style="color:#00a8c8">break</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">NULL</span><span style="color:#111">;</span> <span style="color:#75715e">/* not found */</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><h3 id="遍历">遍历<a href="#%e9%81%8d%e5%8e%86" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>遍历Redis整个数据库主要有两种方式：全遍历（例如keys命令）、间断遍历（hscan命令）:</p>
<ul>
<li>全遍历: 一次命令执行就遍历完整个数据库。</li>
<li>间断遍历: 每次命令执行只取部分数据，分多次遍历。</li>
</ul>
<p>迭代器——可在容器（容器可为字典、链表等数据结构）上遍访的接口，设计人员无须关心容器的内容，调用迭代器固定的接口就可遍历数据，在很多高级语言中都有实现。</p>
<p>字典迭代器主要用于迭代字典这个数据结构中的数据，既然是迭代字典中的数据，必然会出现一个问题，迭代过程中，如果发生了数据增删，则可能导致字典触发rehash操作，或迭代开始时字典正在进行rehash操作，从而导致一条数据可能多次遍历到。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">typedef</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">dictIterator</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">long</span> <span style="color:#111">index</span><span style="color:#111">;</span> <span style="color:#75715e">// 迭代hash中的索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// safe 为1表示是安全迭代器，可以在add,find等rehash场景中使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">int</span> <span style="color:#111">table</span><span style="color:#111">,</span> <span style="color:#111">safe</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// entry 当前读取节点，nextEntry entry 节点的next字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">entry</span><span style="color:#111">,</span> <span style="color:#f92672">*</span><span style="color:#111">nextEntry</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* unsafe iterator fingerprint for misuse detection. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#00a8c8">long</span> <span style="color:#111">fingerprint</span><span style="color:#111">;</span><span style="color:#75715e">// 字典指纹，字典发生改变随之改变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#111">}</span> <span style="color:#111">dictIterator</span><span style="color:#111">;</span>
</span></span></code></pre></div><p>fingerprint字段是一个64位的整数，表示在给定时间内字典的状态。在这里称其为字典的指纹，因为该字段的值为字典（dict结构体）中所有字段值组合在一起生成的Hash值，所以当字典中数据发生任何变化时，其值都会不同，生成算法可参见源码dict.c文件中的dictFingerprint函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* A fingerprint is a 64 bit number that represents the state of the dictionary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * at a given time, it&#39;s just a few dict properties xored together.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * When an unsafe iterator is initialized, we get the dict fingerprint, and check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * the fingerprint again when the iterator is released.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * If the two fingerprints are different it means that the user of the iterator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * performed forbidden operations against the dictionary while iterating. */</span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#00a8c8">long</span> <span style="color:#75af00">dictFingerprint</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">unsigned</span> <span style="color:#00a8c8">long</span> <span style="color:#00a8c8">long</span> <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">6</span><span style="color:#111">],</span> <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">j</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#00a8c8">long</span><span style="color:#111">)</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">2</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">0</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">3</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#00a8c8">long</span><span style="color:#111">)</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_table</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">4</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_size_exp</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#ae81ff">5</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ht_used</span><span style="color:#111">[</span><span style="color:#ae81ff">1</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* We hash N integers by summing every successive integer with the integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * hashing of the previous sum. Basically:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Result = hash(hash(hash(int1)+int2)+int3) ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * This way the same set of integers in a different order will (likely) hash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * to a different number. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#111">j</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">j</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span><span style="color:#111">;</span> <span style="color:#111">j</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">hash</span> <span style="color:#f92672">+=</span> <span style="color:#111">integers</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* For the hashing step we use Tomas Wang&#39;s 64 bit integer hash. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#f92672">~</span><span style="color:#111">hash</span><span style="color:#111">)</span> <span style="color:#f92672">+</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">21</span><span style="color:#111">);</span> <span style="color:#75715e">// hash = (hash &lt;&lt; 21) - hash - 1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">hash</span> <span style="color:#f92672">^</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">24</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">+</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span><span style="color:#111">))</span> <span style="color:#f92672">+</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span><span style="color:#111">);</span> <span style="color:#75715e">// hash * 265
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">hash</span> <span style="color:#f92672">^</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">14</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">+</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#111">))</span> <span style="color:#f92672">+</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span><span style="color:#111">);</span> <span style="color:#75715e">// hash * 21
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">hash</span> <span style="color:#f92672">^</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">28</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">hash</span> <span style="color:#f92672">=</span> <span style="color:#111">hash</span> <span style="color:#f92672">+</span> <span style="color:#111">(</span><span style="color:#111">hash</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">31</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">return</span> <span style="color:#111">hash</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div><p>根据迭代器结构中的safe字段，将迭代器分为普通迭代器和安全迭代器:</p>
<ul>
<li>普通迭代器: 只遍历数据</li>
<li>安全迭代器: 遍历的同时删除数据</li>
</ul>
<h4 id="普通迭代器">普通迭代器<a href="#%e6%99%ae%e9%80%9a%e8%bf%ad%e4%bb%a3%e5%99%a8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<p>普通迭代器迭代字典中数据时，会对迭代器中fingerprint字段的值作严格的校验，来保证迭代过程中字典结构不发生任何变化，确保读取出的数据不出现重复</p>
<p>当Redis执行部分命令时会使用普通迭代器迭代字典数据，例如sort命令。sort命令主要作用是对给定列表、集合、有序集合的元素进行排序，如果给定的是有序集合，其成员名存储用的是字典，分值存储用的是跳跃表，则执行sort命令读取数据的时候会用到迭代器来遍历整个字典。</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>     <span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">set</span> <span style="color:#f92672">=</span> <span style="color:#111">((</span><span style="color:#111">zset</span><span style="color:#f92672">*</span><span style="color:#111">)</span><span style="color:#111">sortval</span><span style="color:#f92672">-&gt;</span><span style="color:#111">ptr</span><span style="color:#111">)</span><span style="color:#f92672">-&gt;</span><span style="color:#111">dict</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">dictIterator</span> <span style="color:#f92672">*</span><span style="color:#111">di</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">dictEntry</span> <span style="color:#f92672">*</span><span style="color:#111">setele</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">sds</span> <span style="color:#111">sdsele</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">di</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictGetIterator</span><span style="color:#111">(</span><span style="color:#111">set</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a8c8">while</span><span style="color:#111">((</span><span style="color:#111">setele</span> <span style="color:#f92672">=</span> <span style="color:#75af00">dictNext</span><span style="color:#111">(</span><span style="color:#111">di</span><span style="color:#111">))</span> <span style="color:#f92672">!=</span> <span style="color:#111">NULL</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">sdsele</span> <span style="color:#f92672">=</span>  <span style="color:#75af00">dictGetKey</span><span style="color:#111">(</span><span style="color:#111">setele</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">vector</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">].</span><span style="color:#111">obj</span> <span style="color:#f92672">=</span> <span style="color:#75af00">createStringObject</span><span style="color:#111">(</span><span style="color:#111">sdsele</span><span style="color:#111">,</span><span style="color:#75af00">sdslen</span><span style="color:#111">(</span><span style="color:#111">sdsele</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">vector</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">].</span><span style="color:#111">u</span><span style="color:#111">.</span><span style="color:#111">score</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">vector</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">].</span><span style="color:#111">u</span><span style="color:#111">.</span><span style="color:#111">cmpobj</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#111">j</span><span style="color:#f92672">++</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75af00">dictReleaseIterator</span><span style="color:#111">(</span><span style="color:#111">di</span><span style="color:#111">);</span>
</span></span></code></pre></div><ol>
<li>
<p>调用dictGetIterator函数初始化一个普通迭代器，此时会把iter-&gt;safe值置为0，表示初始化的迭代器为普通迭代器</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00a8c8">void</span> <span style="color:#75af00">dictInitIterator</span><span style="color:#111">(</span><span style="color:#111">dictIterator</span> <span style="color:#f92672">*</span><span style="color:#111">iter</span><span style="color:#111">,</span> <span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">iter</span><span style="color:#f92672">-&gt;</span><span style="color:#111">d</span> <span style="color:#f92672">=</span> <span style="color:#111">d</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">iter</span><span style="color:#f92672">-&gt;</span><span style="color:#111">table</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">iter</span><span style="color:#f92672">-&gt;</span><span style="color:#111">index</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">iter</span><span style="color:#f92672">-&gt;</span><span style="color:#111">safe</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">iter</span><span style="color:#f92672">-&gt;</span><span style="color:#111">entry</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">iter</span><span style="color:#f92672">-&gt;</span><span style="color:#111">nextEntry</span> <span style="color:#f92672">=</span> <span style="color:#111">NULL</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#111">dictIterator</span> <span style="color:#f92672">*</span><span style="color:#75af00">dictGetIterator</span><span style="color:#111">(</span><span style="color:#111">dict</span> <span style="color:#f92672">*</span><span style="color:#111">d</span><span style="color:#111">)</span>
</span></span><span style="display:flex;"><span><span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">dictIterator</span> <span style="color:#f92672">*</span><span style="color:#111">iter</span> <span style="color:#f92672">=</span> <span style="color:#75af00">zmalloc</span><span style="color:#111">(</span><span style="color:#00a8c8">sizeof</span><span style="color:#111">(</span><span style="color:#f92672">*</span><span style="color:#111">iter</span><span style="color:#111">));</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75af00">dictInitIterator</span><span style="color:#111">(</span><span style="color:#111">iter</span><span style="color:#111">,</span> <span style="color:#111">d</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">return</span> <span style="color:#111">iter</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#111">}</span>
</span></span></code></pre></div></li>
<li>
<p>循环调用dictNext函数依次遍历字典中Hash表的节点，首次遍历时会通过dictFingerprint函数拿到当前字典的指纹值。</p>
</li>
<li></li>
</ol>
<h4 id="安全迭代器">安全迭代器<a href="#%e5%ae%89%e5%85%a8%e8%bf%ad%e4%bb%a3%e5%99%a8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h4>
<h2 id=""><a href="#" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>

		</div>
		
	</main>
<footer id="site-footer" class="section-inner thin animated fadeIn faster">
<p>
	&copy; 2025 <a href="http://localhost:1313/">悉达多</a>
	&#183; &#183; Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a>
	&#183; Theme <a href="https://github.com/1bl4z3r/hermit-V2" target="_blank" rel="noopener">Hermit-V2</a></p></footer>
<script async src="http://localhost:1313/js/bundle.min.c7c384e4d29d192bbac6811ae4660bb01767194a5bea56baca77e8260f93ea16.js" integrity="sha256-x8OE5NKdGSu6xoEa5GYLsBdnGUpb6la6ynfoJg+T6hY=" crossorigin="anonymous"></script><script id="MathJax-script" type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" crossorigin="anonymous"></script>
<script type="text/javascript" id="MathJax-script-helper" async src="http://localhost:1313/js/mathjax-assistant.min.ca29e9d446b2a6cb6c6e3eb0d47e9693f5c306c146eaccb43047afbf31b07a6f.js" integrity="sha256-yinp1Eaypstsbj6w1H6Wk/XDBsFG6sy0MEevvzGwem8=" crossorigin="anonymous"></script>

</body>
</html>
